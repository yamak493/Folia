From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Spottedleaf <Spottedleaf@users.noreply.github.com>
Date: Tue, 3 Oct 2023 06:03:34 -0700
Subject: [PATCH] Region profiler

Profiling for a region starts with the /profiler command.
The usage for /profiler:
/profiler <world> <block x> <block z> <time in s> [radius, default 100 blocks]

Any region within the radius of the specified block coordinates
will be profiled. The profiling will stop after the specified
time has passed.

Once the profiler finishes, it will place a report in
the directory ./profiler/<id>.

Since regions can split into smaller regions, or merge into
other regions, the profiler will track this information. If
a profiled region splits, then all of the regions it splits
into are attached to the same profiler instance. If a profiled
region merges into another region, then the merged region is
profiled. This information is tracked and logged into the
"journal.txt" file contained in the report directory. The
journal tracks the region ids for the merge/split operations.

Region profiling is placed into the "region-X.txt" file where
X is the region id inside the profile directory. The header
of the file describes some stats about the region, namely
total profiling duration, ticks, utilisation, TPS, and MSPT.

Then, the timing tree is follows. The format is as specified:

There are two types of data recorded: Timers and Counters.

Timers are specified as follows:
<indent><name> X% total, Y% parent, self A% total, self B% children, avg D sum E, Fms raw sum
The above specifies the format for a named timer.

The <indent> specifies the number of parent timers.

"X" represents the percentage of time the timer took relative
to the entire profiling instance.

"Y" represents the percentage of time the timer took relative
to its _parents_ timer. For example:
```
Full Tick 100.000% total, 100.000% parent, self 0.889% total, self 0.889% children, avg 200.000 sum 200, 401.300ms raw sum
|+++Tick World: minecraft:overworld 81.409% total, 81.409% parent, self 1.873% total, self 2.301% children, avg 1.000 sum 200, 326.694ms raw sum
|---|---Entity Tick 56.784% total, 69.751% parent, self 6.049% total, self 10.652% children, avg 1.000 sum 200, 227.874ms raw sum
```
"Entity Tick" measured 69.751% of the time for the "Tick World: minecraft:overworld" timer.

"A" represents the self time relative to the entire profiling instance.
The self time is the amount of time for a timer that is _not_ measured
by a child timer.

"B" represents the self time relative to its _parents_ timer.

"D" represents the average number of times the timer is invoked relative to
its parent.
For example:
```
|---|---|---Entity Tick: bat 2.642% total, 7.343% parent, self 2.642% total, self 100.000% children, avg 14.975 sum 2,995, 23.127ms raw sum
```
In this case, an average of 14.975 bats were ticked for every
time the "Entity Tick" timer was invoked.

"E" represents the total number of times the timer is invoked.

"F" represents the total raw time accumulated by the timer.

Counters are specified as follows:
<indent>#<name> avg X sum Y

The X is the average number of times the counter is invoked
relative to the parent, exactly similar to the D field of Timers,
where Y is the total number of times the counter is invoked.

diff --git a/src/main/java/ca/spottedleaf/leafprofiler/LProfileGraph.java b/src/main/java/ca/spottedleaf/leafprofiler/LProfileGraph.java
new file mode 100644
index 0000000000000000000000000000000000000000..19c13bd372711bce978a463f85130f1e10202da9
--- /dev/null
+++ b/src/main/java/ca/spottedleaf/leafprofiler/LProfileGraph.java
@@ -0,0 +1,106 @@
+package ca.spottedleaf.leafprofiler;
+
+import it.unimi.dsi.fastutil.ints.Int2IntMap;
+import it.unimi.dsi.fastutil.ints.Int2IntOpenHashMap;
+import java.util.ArrayDeque;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Iterator;
+import java.util.List;
+
+public final class LProfileGraph {
+
+    public static final int ROOT_NODE = 0;
+    // Array idx is the graph node id, where the int->int mapping is a mapping of profile timer id to graph node id
+    private Int2IntOpenHashMap[] nodes;
+    private int nodeCount;
+
+    public LProfileGraph() {
+        final Int2IntOpenHashMap[] nodes = new Int2IntOpenHashMap[16];
+        nodes[ROOT_NODE] = new Int2IntOpenHashMap();
+
+        this.nodes = nodes;
+        this.nodeCount = 1;
+    }
+
+    public static record GraphNode(GraphNode parent, int nodeId, int timerId) {}
+
+    public List<GraphNode> getDFS() {
+        final List<GraphNode> ret = new ArrayList<>();
+        final ArrayDeque<GraphNode> queue = new ArrayDeque<>();
+
+        queue.addFirst(new GraphNode(null, ROOT_NODE, -1));
+        final Int2IntOpenHashMap[] nodes = this.nodes;
+
+        GraphNode graphNode;
+        while ((graphNode = queue.pollFirst()) != null) {
+            ret.add(graphNode);
+
+            final int parent = graphNode.nodeId;
+
+            final Int2IntOpenHashMap children = nodes[parent];
+
+            for (final Iterator<Int2IntMap.Entry> iterator = children.int2IntEntrySet().fastIterator(); iterator.hasNext();) {
+                final Int2IntMap.Entry entry = iterator.next();
+                queue.addFirst(new GraphNode(graphNode, entry.getIntValue(), entry.getIntKey()));
+            }
+        }
+
+        return ret;
+    }
+
+    private int createNode(final int parent, final int timerId) {
+        Int2IntOpenHashMap[] nodes = this.nodes;
+
+        final Int2IntOpenHashMap node = nodes[parent];
+
+        final int newNode = this.nodeCount;
+        final int prev = node.putIfAbsent(timerId, newNode);
+
+        if (prev != 0) {
+            // already exists
+            return prev;
+        }
+
+        // insert new node
+        ++this.nodeCount;
+
+        if (newNode >= nodes.length) {
+            this.nodes = (nodes = Arrays.copyOf(nodes, nodes.length * 2));
+        }
+
+        nodes[newNode] = new Int2IntOpenHashMap();
+
+        return newNode;
+    }
+
+    public int getNode(final int parent, final int timerId) {
+        // note: requires parent node to exist
+        final Int2IntOpenHashMap[] nodes = this.nodes;
+
+        if (parent >= nodes.length) {
+            return -1;
+        }
+
+        final int mapping = nodes[parent].get(timerId);
+
+        if (mapping != 0) {
+            return mapping;
+        }
+
+        return -1;
+    }
+
+    public int getOrCreateNode(final int parent, final int timerId) {
+        // note: requires parent node to exist
+        final Int2IntOpenHashMap[] nodes = this.nodes;
+
+        final int mapping = nodes[parent].get(timerId);
+
+        if (mapping != 0) {
+            return mapping;
+        }
+
+        return this.createNode(parent, timerId);
+    }
+}
diff --git a/src/main/java/ca/spottedleaf/leafprofiler/LProfilerRegistry.java b/src/main/java/ca/spottedleaf/leafprofiler/LProfilerRegistry.java
new file mode 100644
index 0000000000000000000000000000000000000000..cf81748afe993e486ce27ae65e0148071b029423
--- /dev/null
+++ b/src/main/java/ca/spottedleaf/leafprofiler/LProfilerRegistry.java
@@ -0,0 +1,118 @@
+package ca.spottedleaf.leafprofiler;
+
+import java.util.Arrays;
+import java.util.concurrent.ConcurrentHashMap;
+
+public final class LProfilerRegistry {
+
+    // volatile required to ensure correct publishing when resizing
+    private volatile ProfilerEntry[] typesById = new ProfilerEntry[16];
+    private int totalEntries;
+    private final ConcurrentHashMap<String, ProfilerEntry> nameToEntry = new ConcurrentHashMap<>();
+
+    public LProfilerRegistry() {}
+
+    public ProfilerEntry getById(final int id) {
+        final ProfilerEntry[] entries = this.typesById;
+
+        return id < 0 || id >= entries.length ? null : entries[id];
+    }
+
+    public ProfilerEntry getByName(final String name) {
+        return this.nameToEntry.get(name);
+    }
+
+    public int getOrCreateType(final ProfileType type, final String name) {
+        ProfilerEntry entry = this.nameToEntry.get(name);
+        if (entry != null) {
+            return entry.id;
+        }
+        synchronized (this) {
+            entry = this.nameToEntry.get(name);
+            if (entry != null) {
+                return entry.id;
+            }
+            return this.createType(type, name);
+        }
+    }
+
+    public int getOrCreateTimer(final String name) {
+        return this.getOrCreateType(ProfileType.TIMER, name);
+    }
+
+    public int getOrCreateCounter(final String name) {
+        return this.getOrCreateType(ProfileType.COUNTER, name);
+    }
+
+    public int createType(final ProfileType type, final String name) {
+        synchronized (this) {
+            final int id = this.totalEntries;
+
+            final ProfilerEntry ret = new ProfilerEntry(type, name, id);
+
+            final ProfilerEntry prev = this.nameToEntry.putIfAbsent(name, ret);
+
+            if (prev != null) {
+                throw new IllegalStateException("Entry already exists: " + prev);
+            }
+
+            ++this.totalEntries;
+
+            ProfilerEntry[] entries = this.typesById;
+
+            if (id >= entries.length) {
+                this.typesById = entries = Arrays.copyOf(entries, entries.length * 2);
+            }
+
+            // should be opaque, but I don't think that matters here.
+            entries[id] = ret;
+
+            return id;
+        }
+    }
+
+    public static enum ProfileType {
+        COUNTER, TIMER;
+    }
+
+    public static record ProfilerEntry(ProfileType type, String name, int id) {}
+
+    public static final LProfilerRegistry GLOBAL_REGISTRY = new LProfilerRegistry();
+    public static final int TICK = GLOBAL_REGISTRY.createType(ProfileType.TIMER, "Full Tick");
+    public static final int IN_BETWEEN_TICK = GLOBAL_REGISTRY.createType(ProfileType.TIMER, "In Between Tick");
+    public static final int INTERNAL_TICK_TASKS = GLOBAL_REGISTRY.createType(ProfileType.TIMER, "Internal Tick Tasks");
+    public static final int PLUGIN_TICK_TASKS = GLOBAL_REGISTRY.createType(ProfileType.TIMER, "Plugin Tick Tasks");
+    public static final int ENTITY_SCHEDULER_TICK = GLOBAL_REGISTRY.createType(ProfileType.TIMER, "Entity Scheduler Tick");
+    public static final int ENTITY_SCHEDULERS_TICKED = GLOBAL_REGISTRY.createType(ProfileType.COUNTER, "Entity Schedulers Ticked");
+    public static final int CONNECTION_TICK = GLOBAL_REGISTRY.createType(ProfileType.TIMER, "Connection Tick");
+    public static final int AUTOSAVE = GLOBAL_REGISTRY.createType(ProfileType.TIMER, "Autosave");
+    public static final int PLAYER_SAVE = GLOBAL_REGISTRY.createType(ProfileType.TIMER, "Player Save");
+    public static final int CHUNK_SAVE = GLOBAL_REGISTRY.createType(ProfileType.TIMER, "Chunk Save");
+    public static final int BLOCK_TICK = GLOBAL_REGISTRY.createType(ProfileType.TIMER, "Block Tick");
+    public static final int FLUID_TICK = GLOBAL_REGISTRY.createType(ProfileType.TIMER, "Fluid Tick");
+    public static final int BLOCK_OR_FLUID_TICK_COUNT = GLOBAL_REGISTRY.createType(ProfileType.COUNTER, "Block/Fluid Tick Count");
+    public static final int RAIDS_TICK = GLOBAL_REGISTRY.createType(ProfileType.TIMER, "Raids Tick");
+    public static final int CHUNK_PROVIDER_TICK = GLOBAL_REGISTRY.createType(ProfileType.TIMER, "Chunk Source Tick");
+    public static final int CHUNK_HOLDER_MANAGER_TICK = GLOBAL_REGISTRY.createType(ProfileType.TIMER, "Chunk Holder Manager Tick");
+    public static final int TICKET_LEVEL_UPDATE_PROCESSING = GLOBAL_REGISTRY.createType(ProfileType.TIMER, "Ticket Level Update Processing");
+    public static final int PLAYER_CHUNK_LOADER_TICK = GLOBAL_REGISTRY.createType(ProfileType.TIMER, "Player Chunk Loader Tick");
+    public static final int CHUNK_TICK = GLOBAL_REGISTRY.createType(ProfileType.TIMER, "Chunk Ticks");
+    public static final int CHUNK_TICK_COLLECT_CHUNKS = GLOBAL_REGISTRY.createType(ProfileType.TIMER, "Collect Ticking Chunks");
+    public static final int MOB_SPAWN_ENTITY_COUNT = GLOBAL_REGISTRY.createType(ProfileType.COUNTER, "Mob Spawn Entity Count");
+    public static final int SPAWN_AND_RANDOM_TICK = GLOBAL_REGISTRY.createType(ProfileType.TIMER, "Spawn Entities And Random Tick");
+    public static final int SPAWN_CHUNK_COUNT = GLOBAL_REGISTRY.createType(ProfileType.COUNTER, "Entity Spawn Chunk Count");
+    public static final int RANDOM_CHUNK_TICK_COUNT = GLOBAL_REGISTRY.createType(ProfileType.COUNTER, "Random Chunk Tick Count");
+    public static final int MISC_MOB_SPAWN_TICK = GLOBAL_REGISTRY.createType(ProfileType.TIMER, "Misc Mob Spawn Tick");
+    public static final int BROADCAST_BLOCK_CHANGES = GLOBAL_REGISTRY.createType(ProfileType.TIMER, "Broadcast Block Changes");
+    public static final int ENTITY_TRACKER_TICK = GLOBAL_REGISTRY.createType(ProfileType.TIMER, "Entity Tracker Tick");
+    public static final int TRACKED_ENTITY_COUNTS = GLOBAL_REGISTRY.createType(ProfileType.COUNTER, "Total Tracked Entities");
+    public static final int POI_MANAGER_TICK = GLOBAL_REGISTRY.createType(ProfileType.TIMER, "POI Manager Tick");
+    public static final int PROCESS_UNLOADS = GLOBAL_REGISTRY.createType(ProfileType.TIMER, "Process Unloads");
+    public static final int BLOCK_EVENT_TICK = GLOBAL_REGISTRY.createType(ProfileType.TIMER, "Block Event Tick");
+    public static final int ACTIVATE_ENTITIES = GLOBAL_REGISTRY.createType(ProfileType.TIMER, "Activate Entities");
+    public static final int ENTITY_TICK = GLOBAL_REGISTRY.createType(ProfileType.TIMER, "Entity Tick");
+    public static final int DRAGON_FIGHT_TICK = GLOBAL_REGISTRY.createType(ProfileType.TIMER, "Dragon Fight Tick");
+    public static final int TILE_ENTITY = GLOBAL_REGISTRY.createType(ProfileType.TIMER, "Tile Entities");
+    public static final int TILE_ENTITY_PENDING = GLOBAL_REGISTRY.createType(ProfileType.TIMER, "Tile Entity Handle Pending");
+    public static final int TILE_ENTITY_TICK = GLOBAL_REGISTRY.createType(ProfileType.TIMER, "Tile Entity Tick");
+}
diff --git a/src/main/java/ca/spottedleaf/leafprofiler/LeafProfiler.java b/src/main/java/ca/spottedleaf/leafprofiler/LeafProfiler.java
new file mode 100644
index 0000000000000000000000000000000000000000..d1d259fbf6633ea38799b1519bca6deb623704a3
--- /dev/null
+++ b/src/main/java/ca/spottedleaf/leafprofiler/LeafProfiler.java
@@ -0,0 +1,413 @@
+package ca.spottedleaf.leafprofiler;
+
+import com.mojang.logging.LogUtils;
+import it.unimi.dsi.fastutil.ints.IntArrayFIFOQueue;
+import it.unimi.dsi.fastutil.ints.IntArrayList;
+import it.unimi.dsi.fastutil.ints.IntList;
+import it.unimi.dsi.fastutil.longs.LongArrayFIFOQueue;
+import it.unimi.dsi.fastutil.objects.Reference2ReferenceOpenHashMap;
+import org.slf4j.Logger;
+import java.text.DecimalFormat;
+import java.util.ArrayDeque;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+import java.util.Objects;
+
+public final class LeafProfiler {
+
+    private static final Logger LOGGER = LogUtils.getLogger();
+
+    private static final ThreadLocal<DecimalFormat> THREE_DECIMAL_PLACES = ThreadLocal.withInitial(() -> {
+        return new DecimalFormat("#,##0.000");
+    });
+    private static final ThreadLocal<DecimalFormat> NO_DECIMAL_PLACES = ThreadLocal.withInitial(() -> {
+        return new DecimalFormat("#,##0");
+    });
+
+    public final LProfilerRegistry registry;
+    private final LProfileGraph graph;
+
+    private long[] accumulatedTimers = new long[0];
+    private long[] accumulatedCounters = new long[0];
+
+    private long[] timers = new long[16];
+    private long[] counters = new long[16];
+    private final IntArrayFIFOQueue callStack = new IntArrayFIFOQueue();
+    private int topOfStack = LProfileGraph.ROOT_NODE;
+    private final LongArrayFIFOQueue timerStack = new LongArrayFIFOQueue();
+    private long lastTimerStart = 0L;
+
+    public LeafProfiler(final LProfilerRegistry registry, final LProfileGraph graph) {
+        this.registry = registry;
+        this.graph = graph;
+    }
+
+    private static void add(final long[] dst, final long[] src) {
+        final int srcLen = src.length;
+        Objects.checkFromToIndex(0, srcLen, dst.length);
+        for (int i = 0; i < srcLen; ++i) {
+            dst[i] += src[i];
+        }
+    }
+
+    public ProfilingData copyCurrent() {
+        return new ProfilingData(
+                this.registry, this.graph, this.timers.clone(), this.counters.clone()
+        );
+    }
+
+    public ProfilingData copyAccumulated() {
+        return new ProfilingData(
+                this.registry, this.graph, this.accumulatedTimers.clone(), this.accumulatedCounters.clone()
+        );
+    }
+
+    public void accumulate() {
+        if (this.accumulatedTimers.length != this.timers.length) {
+            this.accumulatedTimers = Arrays.copyOf(this.accumulatedTimers, this.timers.length);
+        }
+        add(this.accumulatedTimers, this.timers);
+        Arrays.fill(this.timers, 0L);
+
+        if (this.accumulatedCounters.length != this.counters.length) {
+            this.accumulatedCounters = Arrays.copyOf(this.accumulatedCounters, this.counters.length);
+        }
+        add(this.accumulatedCounters, this.counters);
+        Arrays.fill(this.counters, 0L);
+    }
+
+    public void clearCurrent() {
+        Arrays.fill(this.timers, 0L);
+        Arrays.fill(this.counters, 0L);
+    }
+
+    private long[] resizeTimers(final long[] old, final int least) {
+        return this.timers = Arrays.copyOf(old, Math.max(old.length * 2, least * 2));
+    }
+
+    private void incrementTimersDirect(final int nodeId, final long count) {
+        final long[] timers = this.timers;
+        if (nodeId >= timers.length) {
+            this.resizeTimers(timers, nodeId)[nodeId] += count;
+        } else {
+            timers[nodeId] += count;
+        }
+    }
+
+    private long[] resizeCounters(final long[] old, final int least) {
+        return this.counters = Arrays.copyOf(old, Math.max(old.length * 2, least * 2));
+    }
+
+    private void incrementCountersDirect(final int nodeId, final long count) {
+        final long[] counters = this.counters;
+        if (nodeId >= counters.length) {
+            this.resizeCounters(counters, nodeId)[nodeId] += count;
+        } else {
+            counters[nodeId] += count;
+        }
+    }
+
+    public void incrementCounter(final int timerId, final long count) {
+        final int node = this.graph.getOrCreateNode(this.topOfStack, timerId);
+        this.incrementCountersDirect(node, count);
+    }
+
+    public void incrementTimer(final int timerId, final long count) {
+        final int node = this.graph.getOrCreateNode(this.topOfStack, timerId);
+        this.incrementTimersDirect(node, count);
+    }
+
+    public void startTimer(final int timerId, final long startTime) {
+        final long lastTimerStart = this.lastTimerStart;
+        final LProfileGraph graph = this.graph;
+        final int parentNode = this.topOfStack;
+        final IntArrayFIFOQueue callStack = this.callStack;
+        final LongArrayFIFOQueue timerStack = this.timerStack;
+
+        this.lastTimerStart = startTime;
+        this.topOfStack = graph.getOrCreateNode(parentNode, timerId);
+
+        callStack.enqueue(parentNode);
+        timerStack.enqueue(lastTimerStart);
+    }
+
+    public void stopTimer(final int timerId, final long endTime) {
+        final long lastStart = this.lastTimerStart;
+        final int currentNode = this.topOfStack;
+        final IntArrayFIFOQueue callStack = this.callStack;
+        final LongArrayFIFOQueue timerStack = this.timerStack;
+        this.lastTimerStart = timerStack.dequeueLastLong();
+        this.topOfStack = callStack.dequeueLastInt();
+
+        if (currentNode != this.graph.getNode(this.topOfStack, timerId)) {
+            final LProfilerRegistry.ProfilerEntry timer = this.registry.getById(timerId);
+            throw new IllegalStateException("Timer " + (timer == null ? "null" : timer.name()) + " did not stop");
+        }
+
+        this.incrementTimersDirect(currentNode, endTime - lastStart);
+        this.incrementCountersDirect(currentNode, 1L);
+    }
+
+    public void stopLastTimer(final long endTime) {
+        final long lastStart = this.lastTimerStart;
+        final int currentNode = this.topOfStack;
+        final IntArrayFIFOQueue callStack = this.callStack;
+        final LongArrayFIFOQueue timerStack = this.timerStack;
+        this.lastTimerStart = timerStack.dequeueLastLong();
+        this.topOfStack = callStack.dequeueLastInt();
+
+        this.incrementTimersDirect(currentNode, endTime - lastStart);
+        this.incrementCountersDirect(currentNode, 1L);
+    }
+
+    private static final class ProfileNode {
+
+        public final ProfileNode parent;
+        public final int nodeId;
+        public final LProfilerRegistry.ProfilerEntry profiler;
+        public final long totalTime;
+        public final long totalCount;
+        public final List<ProfileNode> children = new ArrayList<>();
+        public long childrenTimingCount;
+        public int depth = -1;
+        public boolean lastChild;
+
+        private ProfileNode(final ProfileNode parent, final int nodeId, final LProfilerRegistry.ProfilerEntry profiler,
+                            final long totalTime, final long totalCount) {
+            this.parent = parent;
+            this.nodeId = nodeId;
+            this.profiler = profiler;
+            this.totalTime = totalTime;
+            this.totalCount = totalCount;
+        }
+    }
+
+
+
+    public static final record ProfilingData(
+            LProfilerRegistry registry,
+            LProfileGraph graph,
+            long[] timers,
+            long[] counters
+    ) {
+        public List<String> dumpToString() {
+            final List<LProfileGraph.GraphNode> graphDFS = this.graph.getDFS();
+            final Reference2ReferenceOpenHashMap<LProfileGraph.GraphNode, ProfileNode> nodeMap = new Reference2ReferenceOpenHashMap<>();
+
+            final ArrayDeque<ProfileNode> orderedNodes = new ArrayDeque<>();
+
+            for (int i = 0, len = graphDFS.size(); i < len; ++i) {
+                final LProfileGraph.GraphNode graphNode = graphDFS.get(i);
+                final ProfileNode parent = nodeMap.get(graphNode.parent());
+                final int nodeId = graphNode.nodeId();
+
+                final long totalTime = nodeId >= this.timers.length ? 0L : this.timers[nodeId];
+                final long totalCount = nodeId >= this.counters.length ? 0L : this.counters[nodeId];
+                final LProfilerRegistry.ProfilerEntry profiler = this.registry.getById(graphNode.timerId());
+
+                final ProfileNode profileNode = new ProfileNode(parent, nodeId, profiler, totalTime, totalCount);
+
+                if (parent != null) {
+                    parent.childrenTimingCount += totalTime;
+                    parent.children.add(profileNode);
+                } else if (i != 0) { // i == 0 is root
+                    throw new IllegalStateException("Node " + nodeId + " must have parent");
+                } else {
+                    // set up
+                    orderedNodes.add(profileNode);
+                }
+
+                nodeMap.put(graphNode, profileNode);
+            }
+
+            final List<String> ret = new ArrayList<>();
+
+            long totalTime = 0L;
+
+            // totalTime = sum of times for root node's children
+            for (final ProfileNode node : orderedNodes.peekFirst().children) {
+                totalTime += node.totalTime;
+            }
+
+            final ArrayDeque<ProfileNode> flatOrderedNodes = new ArrayDeque<>();
+
+            ProfileNode profileNode;
+            while ((profileNode = orderedNodes.pollFirst()) != null) {
+                final int depth = profileNode.depth;
+                profileNode.children.sort((final ProfileNode p1, final ProfileNode p2) -> {
+                    final int typeCompare = p1.profiler.type().compareTo(p2.profiler.type());
+                    if (typeCompare != 0) {
+                        // first count, then profiler
+                        return typeCompare;
+                    }
+
+                    if (p1.profiler.type() == LProfilerRegistry.ProfileType.COUNTER) {
+                        // highest count first
+                        return Long.compare(p2.totalCount, p1.totalCount);
+                    } else {
+                        // highest time first
+                        return Long.compare(p2.totalTime, p1.totalTime);
+                    }
+                });
+
+                boolean first = true;
+                for (int i = profileNode.children.size() - 1; i >= 0; --i) {
+                    final ProfileNode child = profileNode.children.get(i);
+                    if (child.totalCount == 0L) {
+                        // skip nodes not recorded
+                        continue;
+                    }
+                    if (first) {
+                        child.lastChild = true;
+                        first = false;
+                    }
+                    child.depth = depth + 1;
+                    orderedNodes.addFirst(child);
+                }
+
+                flatOrderedNodes.addLast(profileNode);
+            }
+
+            final StringBuilder builder = new StringBuilder();
+            final IntList closed = new IntArrayList();
+            while ((profileNode = flatOrderedNodes.pollFirst()) != null) {
+                final int depth = profileNode.depth;
+                closed.removeIf((int d) -> d >= depth);
+                if (profileNode.lastChild) {
+                    closed.add(depth);
+                }
+                if (profileNode.nodeId == LProfileGraph.ROOT_NODE) {
+                    // don't display root
+                    continue;
+                }
+
+                final boolean noParent = profileNode.parent == null || profileNode.parent.nodeId == LProfileGraph.ROOT_NODE;
+
+                final long parentTime = noParent ? totalTime : profileNode.parent.totalTime;
+                final LProfilerRegistry.ProfilerEntry profilerEntry = profileNode.profiler;
+
+                // format:
+                // For profiler type:
+                // <indent><name> X% total, Y% parent, self A% total, self B% children, avg X sum Y, Dms raw sum
+                // For counter type:
+                // <indent>#<name> avg X sum Y
+                builder.setLength(0);
+                // prepare indent
+                for (int i = 0; i < depth; ++i) {
+                    if (i == depth - 1) {
+                        if (flatOrderedNodes.peekFirst() == null || profileNode.lastChild) {
+                            builder.append("  └─");
+                        } else {
+                            builder.append("  ├─");
+                        }
+                    } else if (!closed.contains(i + 1)) {
+                        builder.append("  │ ");
+                    } else {
+                        builder.append("    ");
+                    }
+                }
+
+                switch (profilerEntry.type()) {
+                    case TIMER: {
+                        ret.add(
+                                builder
+                                        .append(profilerEntry.name())
+                                        .append(' ')
+                                        .append(THREE_DECIMAL_PLACES.get().format(((double)profileNode.totalTime / (double)totalTime) * 100.0))
+                                        .append("% total, ")
+                                        .append(THREE_DECIMAL_PLACES.get().format(((double)profileNode.totalTime / (double)parentTime) * 100.0))
+                                        .append("% parent, self ")
+                                        .append(THREE_DECIMAL_PLACES.get().format(((double)(profileNode.totalTime - profileNode.childrenTimingCount) / (double)totalTime) * 100.0))
+                                        .append("% total, self ")
+                                        .append(THREE_DECIMAL_PLACES.get().format(((double)(profileNode.totalTime - profileNode.childrenTimingCount) / (double)profileNode.totalTime) * 100.0))
+                                        .append("% children, avg ")
+                                        .append(THREE_DECIMAL_PLACES.get().format((double)profileNode.totalCount / (double)(noParent ? 1L : profileNode.parent.totalCount)))
+                                        .append(" sum ")
+                                        .append(NO_DECIMAL_PLACES.get().format(profileNode.totalCount))
+                                        .append(", ")
+                                        .append(THREE_DECIMAL_PLACES.get().format((double)profileNode.totalTime / 1.0E6))
+                                        .append("ms raw sum")
+                                        .toString()
+                        );
+                        break;
+                    }
+                    case COUNTER: {
+                        ret.add(
+                                builder
+                                        .append('#')
+                                        .append(profilerEntry.name())
+                                        .append(" avg ")
+                                        .append(THREE_DECIMAL_PLACES.get().format((double)profileNode.totalCount / (double)(noParent ? 1L : profileNode.parent.totalCount)))
+                                        .append(" sum ")
+                                        .append(NO_DECIMAL_PLACES.get().format(profileNode.totalCount))
+                                        .toString()
+                        );
+                        break;
+                    }
+                    default: {
+                        throw new IllegalStateException("Unknown type " + profilerEntry.type());
+                    }
+                }
+            }
+
+            return ret;
+        }
+    }
+
+    /*
+    public static void main(final String[] args) throws Throwable {
+        final Thread timerHack = new Thread("Timer hack thread") {
+            @Override
+            public void run() {
+                for (;;) {
+                    try {
+                        Thread.sleep(Long.MAX_VALUE);
+                    } catch (final InterruptedException ex) {
+                        continue;
+                    }
+                }
+            }
+        };
+        timerHack.setDaemon(true);
+        timerHack.start();
+
+        final LProfilerRegistry registry = new LProfilerRegistry();
+
+        final int tickId = registry.createType(LProfilerRegistry.ProfileType.TIMER, "tick");
+        final int entityTickId = registry.createType(LProfilerRegistry.ProfileType.TIMER, "entity tick");
+        final int getEntitiesId = registry.createType(LProfilerRegistry.ProfileType.COUNTER, "getEntities call");
+        final int tileEntityId = registry.createType(LProfilerRegistry.ProfileType.TIMER, "tile entity tick");
+        final int creeperEntityId = registry.createType(LProfilerRegistry.ProfileType.TIMER, "creeper entity tick");
+        final int furnaceId = registry.createType(LProfilerRegistry.ProfileType.TIMER, "furnace tile entity tick");
+
+        final LeafProfiler profiler = new LeafProfiler(registry, new LProfileGraph());
+
+        profiler.startTimer(tickId, System.nanoTime());
+        Thread.sleep(10L);
+
+        profiler.startTimer(entityTickId, System.nanoTime());
+        Thread.sleep(1L);
+
+        profiler.startTimer(creeperEntityId, System.nanoTime());
+        Thread.sleep(15L);
+        profiler.incrementCounter(getEntitiesId, 50L);
+        profiler.stopTimer(creeperEntityId, System.nanoTime());
+
+        profiler.stopTimer(entityTickId, System.nanoTime());
+
+        profiler.startTimer(tileEntityId, System.nanoTime());
+        Thread.sleep(1L);
+
+        profiler.startTimer(furnaceId, System.nanoTime());
+        Thread.sleep(20L);
+        profiler.stopTimer(furnaceId, System.nanoTime());
+
+        profiler.stopTimer(tileEntityId, System.nanoTime());
+
+        profiler.stopTimer(tickId, System.nanoTime());
+
+        System.out.println("Done.");
+    }
+     */
+}
diff --git a/src/main/java/ca/spottedleaf/leafprofiler/RegionizedProfiler.java b/src/main/java/ca/spottedleaf/leafprofiler/RegionizedProfiler.java
new file mode 100644
index 0000000000000000000000000000000000000000..6e9b04613c5c867a74fa4f266a8ae8e60416cb6d
--- /dev/null
+++ b/src/main/java/ca/spottedleaf/leafprofiler/RegionizedProfiler.java
@@ -0,0 +1,277 @@
+package ca.spottedleaf.leafprofiler;
+
+import ca.spottedleaf.concurrentutil.collection.MultiThreadedQueue;
+import io.papermc.paper.threadedregions.ThreadedRegionizer;
+import io.papermc.paper.threadedregions.TickData;
+import io.papermc.paper.threadedregions.TickRegionScheduler;
+import io.papermc.paper.threadedregions.TickRegions;
+import it.unimi.dsi.fastutil.longs.LongArrayList;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.concurrent.atomic.AtomicLong;
+import java.util.function.Consumer;
+import java.util.function.Supplier;
+
+public final class RegionizedProfiler {
+
+    private static final AtomicLong ID_GENERATOR = new AtomicLong();
+
+    public final long id;
+    private final AtomicInteger profilingRegions = new AtomicInteger();
+    private final MultiThreadedQueue<RecordedOperation> operations = new MultiThreadedQueue<>();
+    private final MultiThreadedQueue<RegionTimings> timings = new MultiThreadedQueue<>();
+    private final long absoluteStart = System.nanoTime();
+    private final long absoluteEnd;
+    private final Consumer<ProfileResults> onFinish;
+
+    public RegionizedProfiler(final long id, final long recordFor, final Consumer<ProfileResults> onFinish) {
+        this.id = id;
+        this.onFinish = onFinish;
+        this.absoluteEnd = this.absoluteStart + recordFor;
+    }
+
+    public void createProfiler(final ThreadedRegionizer.ThreadedRegion<TickRegions.TickRegionData, TickRegions.TickRegionSectionData> into) {
+        final Handle newProfiler = new Handle(
+            new LeafProfiler(LProfilerRegistry.GLOBAL_REGISTRY, new LProfileGraph()),
+            false, this, into
+        );
+        newProfiler.startProfiler();
+
+        into.getData().profiler = newProfiler;
+    }
+
+    public void preMerge(final ThreadedRegionizer.ThreadedRegion<TickRegions.TickRegionData, TickRegions.TickRegionSectionData> from,
+                         final ThreadedRegionizer.ThreadedRegion<TickRegions.TickRegionData, TickRegions.TickRegionSectionData> into) {
+        final Handle fromProfiler = from.getData().profiler;
+        final Handle intoProfiler = into.getData().profiler;
+        this.operations.add(new RecordedOperation(OperationType.MERGE, from.id, LongArrayList.of(into.id), System.nanoTime()));
+
+        if (intoProfiler != null) {
+            // target is already profiling
+            fromProfiler.stopProfiler();
+            return;
+        }
+
+        this.createProfiler(into);
+
+        // the old profiler must be terminated only after creating the new one, so that there is always at least one
+        // profiler running, otherwise the profiler will complete
+        fromProfiler.stopProfiler();
+    }
+
+    public void preSplit(final ThreadedRegionizer.ThreadedRegion<TickRegions.TickRegionData, TickRegions.TickRegionSectionData> from,
+                         final List<ThreadedRegionizer.ThreadedRegion<TickRegions.TickRegionData, TickRegions.TickRegionSectionData>> into) {
+        final Handle fromProfiler = from.getData().profiler;
+
+        final LongArrayList regions = new LongArrayList(into.size());
+        for (int i = 0, len = into.size(); i < len; ++i) {
+            regions.add(into.get(i).id);
+        }
+
+        this.operations.add(new RecordedOperation(OperationType.SPLIT, from.id, regions, System.nanoTime()));
+
+        for (int i = 0, len = into.size(); i < len; ++i) {
+            // create new profiler
+            this.createProfiler(into.get(i));
+        }
+
+        // the old profiler must be terminated only after creating the new ones, so that there is always at least one
+        // profiler running, otherwise the profiler will complete
+        fromProfiler.stopProfiler();
+    }
+
+    public static record RecordedOperation(
+        OperationType type,
+
+        /*
+         * The target for start,end or the `from` region for merge/split
+         */
+        long regionOfInterest,
+
+        /*
+         * The merge target or the split targets
+         */
+        LongArrayList targetRegions,
+
+        /*
+         * The timestamp for this operation
+         */
+        long time
+    ) {}
+
+    public static enum OperationType {
+        START,
+        MERGE,
+        SPLIT,
+        END;
+    }
+
+    public static final class Handle {
+
+        public final LeafProfiler profiler;
+        private boolean noOp;
+        public final RegionizedProfiler profilerGroup;
+        private final ThreadedRegionizer.ThreadedRegion<TickRegions.TickRegionData, TickRegions.TickRegionSectionData> region;
+        private final TickData tickData = new TickData(Long.MAX_VALUE);
+        private long startTime;
+
+        public static final Handle NO_OP_HANDLE = new Handle(
+            null, true, null, null
+        );
+
+        private Handle(final LeafProfiler profiler, final boolean noOp,
+                       final RegionizedProfiler profilerGroup,
+                       final ThreadedRegionizer.ThreadedRegion<TickRegions.TickRegionData, TickRegions.TickRegionSectionData> region) {
+            this.profiler = profiler;
+            this.noOp = noOp;
+            this.profilerGroup = profilerGroup;
+            this.region = region;
+        }
+
+        public void startTick() {
+            if (this.noOp) {
+                return;
+            }
+
+            this.profiler.startTimer(LProfilerRegistry.TICK, System.nanoTime());
+        }
+
+        public void stopTick() {
+            if (this.noOp) {
+                return;
+            }
+
+
+
+            this.profiler.stopTimer(LProfilerRegistry.TICK, System.nanoTime());
+            this.profiler.accumulate();
+        }
+
+        public void startInBetweenTick() {
+            if (this.noOp) {
+                return;
+            }
+
+            this.profiler.startTimer(LProfilerRegistry.IN_BETWEEN_TICK, System.nanoTime());
+        }
+
+        public void stopInBetweenTick() {
+            if (this.noOp) {
+                return;
+            }
+
+            this.profiler.stopTimer(LProfilerRegistry.IN_BETWEEN_TICK, System.nanoTime());
+        }
+
+        public void startTimer(final int timerId) {
+            if (this.noOp) {
+                return;
+            }
+
+            this.profiler.startTimer(timerId, System.nanoTime());
+        }
+
+        public void stopTimer(final int timerId) {
+            if (this.noOp) {
+                return;
+            }
+
+            this.profiler.stopTimer(timerId, System.nanoTime());
+        }
+
+        public void addCounter(final int counterId, final long count) {
+            if (this.noOp) {
+                return;
+            }
+
+            this.profiler.incrementCounter(counterId, count);
+        }
+
+        public int getOrCreateTimerAndStart(final Supplier<String> name) {
+            if (this.noOp) {
+                return -1;
+            }
+
+            final int timer = this.profiler.registry.getOrCreateType(LProfilerRegistry.ProfileType.TIMER, name.get());
+
+            this.profiler.startTimer(timer, System.nanoTime());
+
+            return timer;
+        }
+
+        public void addTickTime(final TickRegionScheduler.TickTime tickTime) {
+            if (this.noOp) {
+                return;
+            }
+            this.tickData.addDataFrom(tickTime);
+        }
+
+        public void startProfiler() {
+            if (this.noOp) {
+                return;
+            }
+            this.profilerGroup.profilingRegions.getAndIncrement();
+            this.startTime = System.nanoTime();
+            this.profilerGroup.operations.add(
+                new RecordedOperation(OperationType.START, this.region.id, new LongArrayList(), this.startTime)
+            );
+        }
+
+        public void stopProfiler() {
+            if (this.noOp) {
+                return;
+            }
+
+            final long endTime = System.nanoTime();
+
+            this.noOp = true;
+            this.region.getData().profiler = null;
+            this.profilerGroup.operations.add(
+                new RecordedOperation(OperationType.END, this.region.id, new LongArrayList(), endTime)
+            );
+            this.profilerGroup.timings.add(
+                new RegionTimings(
+                    this.startTime, endTime, this.region.id, this.profiler, this.tickData
+                )
+            );
+
+            if (this.profilerGroup.profilingRegions.decrementAndGet() == 0) {
+                this.profilerGroup.onFinish.accept(
+                    new ProfileResults(
+                        this.profilerGroup.id,
+                        this.profilerGroup.absoluteStart,
+                        endTime,
+                        new ArrayList<>(this.profilerGroup.timings),
+                        new ArrayList<>(this.profilerGroup.operations)
+                    )
+                );
+            }
+        }
+
+        public void checkStop() {
+            if (this.noOp) {
+                return;
+            }
+            if ((System.nanoTime() - this.profilerGroup.absoluteEnd) >= 0L) {
+                this.stopProfiler();
+            }
+        }
+    }
+
+    public static record ProfileResults(
+        long profileId,
+        long startTime,
+        long endTime,
+        List<RegionTimings> timings,
+        List<RecordedOperation> operations
+    ) {}
+
+    public static record RegionTimings(
+        long startTime,
+        long endTime,
+        long regionId,
+        LeafProfiler profiler,
+        TickData tickData
+    ) {}
+}
diff --git a/src/main/java/ca/spottedleaf/moonrise/patches/chunk_system/scheduling/ChunkHolderManager.java b/src/main/java/ca/spottedleaf/moonrise/patches/chunk_system/scheduling/ChunkHolderManager.java
index 3a476713964002734a9e67fd9b6dfa497b590657..e176d2d2387e171ff163853131dcf8d1af9a268d 100644
--- a/src/main/java/ca/spottedleaf/moonrise/patches/chunk_system/scheduling/ChunkHolderManager.java
+++ b/src/main/java/ca/spottedleaf/moonrise/patches/chunk_system/scheduling/ChunkHolderManager.java
@@ -1459,7 +1459,9 @@ public final class ChunkHolderManager {
     }
 
     public boolean processTicketUpdates() {
+        final ca.spottedleaf.leafprofiler.RegionizedProfiler.Handle profiler = io.papermc.paper.threadedregions.TickRegionScheduler.getProfiler(); profiler.startTimer(ca.spottedleaf.leafprofiler.LProfilerRegistry.TICKET_LEVEL_UPDATE_PROCESSING); try { // Folia - profiler
         return this.processTicketUpdates(true, null);
+        } finally { profiler.stopTimer(ca.spottedleaf.leafprofiler.LProfilerRegistry.TICKET_LEVEL_UPDATE_PROCESSING); } // Folia - profiler
     }
 
     private static final ThreadLocal<List<ChunkProgressionTask>> CURRENT_TICKET_UPDATE_SCHEDULING = new ThreadLocal<>();
diff --git a/src/main/java/ca/spottedleaf/moonrise/patches/chunk_system/scheduling/NewChunkHolder.java b/src/main/java/ca/spottedleaf/moonrise/patches/chunk_system/scheduling/NewChunkHolder.java
index 9e7e10fe46dbbd03d690a65af6ae719d1665bc6a..6edbe46c5c2eb74bca7e437474a6e992f45a04f8 100644
--- a/src/main/java/ca/spottedleaf/moonrise/patches/chunk_system/scheduling/NewChunkHolder.java
+++ b/src/main/java/ca/spottedleaf/moonrise/patches/chunk_system/scheduling/NewChunkHolder.java
@@ -1680,6 +1680,8 @@ public final class NewChunkHolder {
 
     public SaveStat save(final boolean shutdown) {
         TickThread.ensureTickThread(this.world, this.chunkX, this.chunkZ, "Cannot save data off-main");
+        final ca.spottedleaf.leafprofiler.RegionizedProfiler.Handle profiler = io.papermc.paper.threadedregions.TickRegionScheduler.getProfiler(); // Folia - profiler
+        profiler.startTimer(ca.spottedleaf.leafprofiler.LProfilerRegistry.CHUNK_SAVE); try { // Folia - profiler
 
         ChunkAccess chunk = this.getCurrentChunk();
         PoiChunk poi = this.getPoiChunk();
@@ -1738,6 +1740,7 @@ public final class NewChunkHolder {
                         canSavePOI | executedUnloadTasks[MoonriseRegionFileIO.RegionFileType.POI_DATA.ordinal()]
                 )
                 : null;
+        } finally { profiler.stopTimer(ca.spottedleaf.leafprofiler.LProfilerRegistry.CHUNK_SAVE); } // Folia - profiler
     }
 
     private boolean saveChunk(final ChunkAccess chunk, final boolean unloading) {
diff --git a/src/main/java/io/papermc/paper/command/PaperCommands.java b/src/main/java/io/papermc/paper/command/PaperCommands.java
index a587d83b78af4efc484f939529acf70834f60d7e..45f76aaaa7dedb77a83b4a2c87905bf9a099a93c 100644
--- a/src/main/java/io/papermc/paper/command/PaperCommands.java
+++ b/src/main/java/io/papermc/paper/command/PaperCommands.java
@@ -20,6 +20,7 @@ public final class PaperCommands {
         COMMANDS.put("callback", new CallbackCommand("callback"));
         COMMANDS.put("mspt", new MSPTCommand("mspt"));
         COMMANDS.put("tps", new io.papermc.paper.threadedregions.commands.CommandServerHealth()); // Folia - region threading
+        COMMANDS.put("profiler", new io.papermc.paper.threadedregions.commands.CommandProfiler()); // Folia - region threading - profiler
     }
 
     public static void registerCommands(final MinecraftServer server) {
diff --git a/src/main/java/io/papermc/paper/threadedregions/TickRegionScheduler.java b/src/main/java/io/papermc/paper/threadedregions/TickRegionScheduler.java
index 4471285a4358e51da9912ed791a824527f1a2e8e..a18da3f3f245031f0547efe9b52a1f2a219ef04a 100644
--- a/src/main/java/io/papermc/paper/threadedregions/TickRegionScheduler.java
+++ b/src/main/java/io/papermc/paper/threadedregions/TickRegionScheduler.java
@@ -67,8 +67,13 @@ public final class TickRegionScheduler {
         tickThreadRunner.currentTickingRegion = region;
         if (region != null) {
             tickThreadRunner.currentTickingWorldRegionizedData = region.regioniser.world.worldRegionData.get();
+            // Folia start - profiler
+            final ca.spottedleaf.leafprofiler.RegionizedProfiler.Handle profiler = region.getData().profiler;
+            tickThreadRunner.profiler = profiler == null ? ca.spottedleaf.leafprofiler.RegionizedProfiler.Handle.NO_OP_HANDLE : profiler;
+            // Folia end - profiler
         } else {
             tickThreadRunner.currentTickingWorldRegionizedData = null;
+            tickThreadRunner.profiler = ca.spottedleaf.leafprofiler.RegionizedProfiler.Handle.NO_OP_HANDLE; // Folia - profiler
         }
     }
 
@@ -123,6 +128,17 @@ public final class TickRegionScheduler {
         return tickThreadRunner.currentTickingTask;
     }
 
+    // Folia start - profiler
+    public static ca.spottedleaf.leafprofiler.RegionizedProfiler.Handle getProfiler() {
+        final Thread currThread = Thread.currentThread();
+        if (!(currThread instanceof TickThreadRunner tickThreadRunner)) {
+            return ca.spottedleaf.leafprofiler.RegionizedProfiler.Handle.NO_OP_HANDLE;
+        }
+        return tickThreadRunner.profiler;
+    }
+    // Folia end - profiler
+
+
     /**
      * Schedules the given region
      * @throws IllegalStateException If the region is already scheduled or is ticking
@@ -204,6 +220,9 @@ public final class TickRegionScheduler {
         private ThreadedRegionizer.ThreadedRegion<TickRegions.TickRegionData, TickRegions.TickRegionSectionData> currentTickingRegion;
         private RegionizedWorldData currentTickingWorldRegionizedData;
         private SchedulerThreadPool.SchedulableTick currentTickingTask;
+        // Folia start - profiler
+        private ca.spottedleaf.leafprofiler.RegionizedProfiler.Handle profiler = ca.spottedleaf.leafprofiler.RegionizedProfiler.Handle.NO_OP_HANDLE;
+        // Folia end - profiler
 
         public TickThreadRunner(final Runnable run, final String name) {
             super(run, name);
diff --git a/src/main/java/io/papermc/paper/threadedregions/TickRegions.java b/src/main/java/io/papermc/paper/threadedregions/TickRegions.java
index df15b1139e71dfe10b8f24ec6d235b99f6d5006a..b1c07e582dbf0a203cf734fdbcd8387a422af3a6 100644
--- a/src/main/java/io/papermc/paper/threadedregions/TickRegions.java
+++ b/src/main/java/io/papermc/paper/threadedregions/TickRegions.java
@@ -81,6 +81,11 @@ public final class TickRegions implements ThreadedRegionizer.RegionCallbacks<Tic
     @Override
     public void onRegionDestroy(final ThreadedRegionizer.ThreadedRegion<TickRegionData, TickRegionSectionData> region) {
         // nothing for now
+        // Folia start - profiler
+        if (region.getData().profiler != null) {
+            region.getData().profiler.stopProfiler();
+        }
+        // Folia end - profiler
     }
 
     @Override
@@ -103,13 +108,23 @@ public final class TickRegions implements ThreadedRegionizer.RegionCallbacks<Tic
     @Override
     public void preMerge(final ThreadedRegionizer.ThreadedRegion<TickRegionData, TickRegionSectionData> from,
                          final ThreadedRegionizer.ThreadedRegion<TickRegionData, TickRegionSectionData> into) {
-
+        // Folia start - profiler
+        final ca.spottedleaf.leafprofiler.RegionizedProfiler.Handle profiler = from.getData().profiler;
+        if (profiler != null) {
+            profiler.profilerGroup.preMerge(from, into);
+        }
+        // Folia end - profiler
     }
 
     @Override
     public void preSplit(final ThreadedRegionizer.ThreadedRegion<TickRegionData, TickRegionSectionData> from,
                          final java.util.List<ThreadedRegionizer.ThreadedRegion<TickRegionData, TickRegionSectionData>> into) {
-
+        // Folia start - profiler
+        final ca.spottedleaf.leafprofiler.RegionizedProfiler.Handle profiler = from.getData().profiler;
+        if (profiler != null) {
+            profiler.profilerGroup.preSplit(from, into);
+        }
+        // Folia end - profiler
     }
 
     public static final class TickRegionSectionData implements ThreadedRegionizer.ThreadedRegionSectionData {}
@@ -167,6 +182,8 @@ public final class TickRegions implements ThreadedRegionizer.RegionCallbacks<Tic
         // async-safe read-only region data
         private final RegionStats regionStats;
 
+        public volatile ca.spottedleaf.leafprofiler.RegionizedProfiler.Handle profiler; // Folia - profiler
+
         private TickRegionData(final ThreadedRegionizer.ThreadedRegion<TickRegionData, TickRegionSectionData> region) {
             this.region = region;
             this.world = region.regioniser.world;
@@ -372,13 +389,29 @@ public final class TickRegions implements ThreadedRegionizer.RegionCallbacks<Tic
             return this.region.region.markNotTicking();
         }
 
+        // Folia start - profiler
+        @Override
+        protected void addTickTime(final TickRegionScheduler.TickTime time) {
+            super.addTickTime(time);
+
+            final ca.spottedleaf.leafprofiler.RegionizedProfiler.Handle profiler = io.papermc.paper.threadedregions.TickRegionScheduler.getProfiler();
+            profiler.addTickTime(time);
+            profiler.checkStop();
+         }
+         // Folia end - profiler
+
         @Override
         protected void tickRegion(final int tickCount, final long startTime, final long scheduledEnd) {
+            final ca.spottedleaf.leafprofiler.RegionizedProfiler.Handle profiler = io.papermc.paper.threadedregions.TickRegionScheduler.getProfiler(); // Folia - profiler
+            profiler.startTick(); try { // Folia - profiler
             MinecraftServer.getServer().tickServer(startTime, scheduledEnd, TimeUnit.MILLISECONDS.toMillis(10L), this.region);
+            } finally { profiler.stopTick(); } // Folia - profiler
         }
 
         @Override
         protected boolean runRegionTasks(final BooleanSupplier canContinue) {
+            final ca.spottedleaf.leafprofiler.RegionizedProfiler.Handle profiler = io.papermc.paper.threadedregions.TickRegionScheduler.getProfiler(); // Folia start - profiler
+            profiler.startInBetweenTick(); try { // Folia - profiler
             final RegionizedTaskQueue.RegionTaskQueueData queue = this.region.taskQueueData;
 
             boolean processedChunkTask = false;
@@ -399,6 +432,7 @@ public final class TickRegions implements ThreadedRegionizer.RegionCallbacks<Tic
                 this.region.world.moonrise$getChunkTaskScheduler().chunkHolderManager.processTicketUpdates();
             }
             return true;
+            } finally { profiler.stopInBetweenTick(); } // Folia - profiler
         }
 
         @Override
diff --git a/src/main/java/io/papermc/paper/threadedregions/commands/CommandProfiler.java b/src/main/java/io/papermc/paper/threadedregions/commands/CommandProfiler.java
new file mode 100644
index 0000000000000000000000000000000000000000..3c6f0359bd6196eeb497bc2a43a82186b545df4e
--- /dev/null
+++ b/src/main/java/io/papermc/paper/threadedregions/commands/CommandProfiler.java
@@ -0,0 +1,245 @@
+package io.papermc.paper.threadedregions.commands;
+
+import ca.spottedleaf.leafprofiler.RegionizedProfiler;
+import com.mojang.logging.LogUtils;
+import io.papermc.paper.threadedregions.ThreadedRegionizer;
+import io.papermc.paper.threadedregions.TickData;
+import io.papermc.paper.threadedregions.TickRegions;
+import io.papermc.paper.util.MCUtil;
+import net.kyori.adventure.text.Component;
+import net.kyori.adventure.text.format.NamedTextColor;
+import net.kyori.adventure.text.format.TextColor;
+import net.minecraft.util.Mth;
+import net.minecraft.world.level.ChunkPos;
+import org.bukkit.Bukkit;
+import org.bukkit.World;
+import org.bukkit.command.Command;
+import org.bukkit.command.CommandSender;
+import org.bukkit.craftbukkit.CraftWorld;
+import org.bukkit.entity.Entity;
+import org.slf4j.Logger;
+import java.io.File;
+import java.io.IOException;
+import java.nio.charset.StandardCharsets;
+import java.nio.file.Files;
+import java.nio.file.StandardOpenOption;
+import java.text.DecimalFormat;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Objects;
+import java.util.Set;
+import java.util.concurrent.ThreadLocalRandom;
+
+public final class CommandProfiler extends Command {
+
+    private static final Logger LOGGER = LogUtils.getLogger();
+
+    private static final ThreadLocal<DecimalFormat> THREE_DECIMAL_PLACES = ThreadLocal.withInitial(() -> {
+        return new DecimalFormat("#,##0.000");
+    });
+    private static final ThreadLocal<DecimalFormat> TWO_DECIMAL_PLACES = ThreadLocal.withInitial(() -> {
+        return new DecimalFormat("#,##0.00");
+    });
+    private static final ThreadLocal<DecimalFormat> ONE_DECIMAL_PLACES = ThreadLocal.withInitial(() -> {
+        return new DecimalFormat("#,##0.0");
+    });
+    private static final ThreadLocal<DecimalFormat> NO_DECIMAL_PLACES = ThreadLocal.withInitial(() -> {
+        return new DecimalFormat("#,##0");
+    });
+    private static final TextColor ORANGE = TextColor.color(255, 165, 0);
+
+    public CommandProfiler() {
+        super("profiler");
+        this.setUsage("/<command> <world> <block x> <block z> <time in s> [radius, default 100 blocks]");
+        this.setDescription("Reports information about server health.");
+        this.setPermission("bukkit.command.tps");
+    }
+
+    @Override
+    public boolean execute(final CommandSender sender, final String commandLabel, final String[] args) {
+        if (args.length < 4 || args.length > 5) {
+            sender.sendMessage(Component.text("Usage: /profiler <world> <block x> <block z> <time in s> [radius, default 100 blocks]", NamedTextColor.RED));
+            return true;
+        }
+
+        final World world = Bukkit.getWorld(args[0]);
+        if (world == null) {
+            sender.sendMessage(Component.text("No such world '" + args[0] + "'", NamedTextColor.RED));
+            return true;
+        }
+
+        final double blockX;
+        final double blockZ;
+        final double time; // seconds
+        try {
+            blockX = (args[1].equals("~") && sender instanceof Entity entity) ? entity.getLocation().getX() : Double.parseDouble(args[1]);
+        } catch (final NumberFormatException ex) {
+            sender.sendMessage(Component.text("Invalid input for block x: " + args[1], NamedTextColor.RED));
+            return true;
+        }
+        try {
+            blockZ = (args[2].equals("~") && sender instanceof Entity entity) ? entity.getLocation().getZ() : Double.parseDouble(args[2]);
+        } catch (final NumberFormatException ex) {
+            sender.sendMessage(Component.text("Invalid input for block z: " + args[2], NamedTextColor.RED));
+            return true;
+        }
+        try {
+            time = Double.parseDouble(args[3]);
+        } catch (final NumberFormatException ex) {
+            sender.sendMessage(Component.text("Invalid input for time: " + args[3], NamedTextColor.RED));
+            return true;
+        }
+
+        final double radius;
+        if (args.length > 4) {
+            try {
+                radius = Double.parseDouble(args[4]);
+            } catch (final NumberFormatException ex) {
+                sender.sendMessage(Component.text("Invalid input for radius: " + args[4], NamedTextColor.RED));
+                return true;
+            }
+        } else {
+            radius = 100.0;
+        }
+
+        final int fromChunkX = Mth.floor(blockX - radius) >> 4;
+        final int fromChunkZ = Mth.floor(blockZ - radius) >> 4;
+        final int toChunkX = Mth.floor(blockX + radius) >> 4;
+        final int toChunkZ = Mth.floor(blockZ + radius) >> 4;
+
+        final RegionizedProfiler profiler = new RegionizedProfiler(
+            ThreadLocalRandom.current().nextLong(), (long)Math.ceil(time * 1.0E9),
+            (final RegionizedProfiler.ProfileResults results) -> {
+                MCUtil.asyncExecutor.execute(() -> {
+                    writeResults(results);
+                    sender.sendMessage(
+                        Component.text()
+                            .append(Component.text("Finished profiler #", NamedTextColor.DARK_GRAY))
+                            .append(Component.text(Long.toString(results.profileId()), ORANGE))
+                            .append(Component.text(", result available in ", NamedTextColor.DARK_GRAY))
+                            .append(Component.text("./profiler/" + results.profileId(), ORANGE))
+                            .build()
+                    );
+                });
+            }
+        );
+
+        final int regionCount = ((CraftWorld)world).getHandle().regioniser.computeForRegions(
+            fromChunkX, fromChunkZ, toChunkX, toChunkZ,
+            (final Set<ThreadedRegionizer.ThreadedRegion<TickRegions.TickRegionData, TickRegions.TickRegionSectionData>> set) -> {
+                for (final ThreadedRegionizer.ThreadedRegion<TickRegions.TickRegionData, TickRegions.TickRegionSectionData> region : set) {
+                    final TickRegions.TickRegionData data = region.getData();
+                    final ChunkPos center = region.getCenterChunk();
+
+                    if (data.profiler != null) {
+                        MCUtil.asyncExecutor.execute(() -> {
+                            sender.sendMessage(
+                                Component.text()
+                                    .append(Component.text("Region #", NamedTextColor.DARK_GRAY))
+                                    .append(Component.text(region.id, ORANGE))
+                                    .append(Component.text(" centered on ", NamedTextColor.DARK_GRAY))
+                                    .append(Component.text(Objects.toString(center), ORANGE))
+                                    .append(Component.text(" already is being profiled", NamedTextColor.DARK_GRAY))
+                                    .build()
+                            );
+                        });
+                        continue;
+                    }
+
+                    profiler.createProfiler(region);
+                    MCUtil.asyncExecutor.execute(() -> {
+                        sender.sendMessage(
+                            Component.text()
+                                .append(Component.text("Started profiler #", NamedTextColor.DARK_GRAY))
+                                .append(Component.text(Long.toString(profiler.id), ORANGE))
+                                .append(Component.text(" for region #", NamedTextColor.DARK_GRAY))
+                                .append(Component.text(Long.toString(region.id), ORANGE))
+                                .append(Component.text(" centered on chunk ", NamedTextColor.DARK_GRAY))
+                                .append(Component.text(Objects.toString(center), ORANGE))
+                                .build()
+                        );
+                    });
+                }
+            }
+        );
+
+        if (regionCount == 0) {
+            sender.sendMessage(
+                Component.text()
+                    .append(Component.text("No regions around specified location in radius to profile", NamedTextColor.RED))
+            );
+        }
+
+        return true;
+    }
+
+    private static void writeLines(final File file, final List<String> lines) {
+        try {
+            Files.write(
+                file.toPath(), lines, StandardCharsets.UTF_8,
+                StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING, StandardOpenOption.WRITE
+            );
+        } catch (final IOException ex) {
+            LOGGER.warn("Failed to write to profiler file " + file.getAbsolutePath(), ex);
+        }
+    }
+
+    private static void writeResults(final RegionizedProfiler.ProfileResults results) {
+        final File directory = new File(new File(".", "profiler"), Long.toString(results.profileId()));
+
+        directory.mkdirs();
+
+        // write region data
+        for (final RegionizedProfiler.RegionTimings regionTimings : results.timings()) {
+            final File regionProfile = new File(directory, "region-" + regionTimings.regionId() + ".txt");
+            final TickData.TickReportData tickReport = regionTimings.tickData().generateTickReport(null, regionTimings.endTime());
+
+            final List<String> out = new ArrayList<>();
+            out.add("Total time: " + THREE_DECIMAL_PLACES.get().format(1.0E-9 * (regionTimings.endTime() - regionTimings.startTime())) + "s");
+            out.add("Total Ticks: " + NO_DECIMAL_PLACES.get().format(tickReport == null ? 0 : tickReport.collectedTicks()));
+            out.add("Utilisation: " + THREE_DECIMAL_PLACES.get().format(tickReport == null ? 0.0 : 100.0 * tickReport.utilisation()) + "%");
+            out.add("");
+            out.add("Min TPS: " + THREE_DECIMAL_PLACES.get().format(tickReport == null ? 20.0 : tickReport.tpsData().segmentAll().least()));
+            out.add("Median TPS: " + THREE_DECIMAL_PLACES.get().format(tickReport == null ? 20.0 : tickReport.tpsData().segmentAll().median()));
+            out.add("Average TPS: " + THREE_DECIMAL_PLACES.get().format(tickReport == null ? 20.0 : tickReport.tpsData().segmentAll().average()));
+            out.add("Max TPS: " + THREE_DECIMAL_PLACES.get().format(tickReport == null ? 20.0 : tickReport.tpsData().segmentAll().greatest()));
+            out.add("");
+            out.add("Min MSPT: " + THREE_DECIMAL_PLACES.get().format(tickReport == null ? 0.0 : 1.0E-6 * tickReport.timePerTickData().segmentAll().least()));
+            out.add("Median MSPT: " + THREE_DECIMAL_PLACES.get().format(tickReport == null ? 0.0 : 1.0E-6 *tickReport.timePerTickData().segmentAll().median()));
+            out.add("Average MSPT: " + THREE_DECIMAL_PLACES.get().format(tickReport == null ? 0.0 : 1.0E-6 *tickReport.timePerTickData().segmentAll().average()));
+            out.add("Max MSPT: " + THREE_DECIMAL_PLACES.get().format(tickReport == null ? 0.0 : 1.0E-6 *tickReport.timePerTickData().segmentAll().greatest()));
+            out.add("");
+
+            out.addAll(regionTimings.profiler().copyAccumulated().dumpToString());
+            writeLines(regionProfile, out);
+        }
+
+        // write journal
+        final File journal = new File(directory, "journal.txt");
+        final List<String> journalLines = new ArrayList<>();
+
+        for (final RegionizedProfiler.RecordedOperation operation : results.operations()) {
+            final String indent = "    ";
+            journalLines.add("Recorded Operation:");
+            journalLines.add(indent + "Type: " + operation.type());
+            journalLines.add(indent + "Time: " + THREE_DECIMAL_PLACES.get().format(1.0E-9 * (operation.time() - results.startTime())) + "s");
+            journalLines.add(indent + "From Region: " + operation.regionOfInterest());
+            journalLines.add(indent + "Target Other Regions: " + operation.targetRegions().toString());
+        }
+
+        journalLines.add("Total time: " + THREE_DECIMAL_PLACES.get().format(1.0E-9 * (results.endTime() - results.startTime())) + "s");
+        writeLines(journal, journalLines);
+
+    }
+
+    @Override
+    public List<String> tabComplete(final CommandSender sender, final String alias, final String[] args) throws IllegalArgumentException {
+        if (args.length == 0) {
+            return CommandUtil.getSortedList(Bukkit.getWorlds(), World::getName);
+        }
+        if (args.length == 1) {
+            return CommandUtil.getSortedList(Bukkit.getWorlds(), World::getName, args[0]);
+        }
+        return new ArrayList<>();
+    }
+}
diff --git a/src/main/java/net/minecraft/network/protocol/PacketUtils.java b/src/main/java/net/minecraft/network/protocol/PacketUtils.java
index d6eb8f495688a1b65a4c419aa3ee655cd8eb322a..f338b273613840ed366ab13b528373e7091631e8 100644
--- a/src/main/java/net/minecraft/network/protocol/PacketUtils.java
+++ b/src/main/java/net/minecraft/network/protocol/PacketUtils.java
@@ -52,7 +52,10 @@ public class PacketUtils {
                 if (listener instanceof ServerCommonPacketListenerImpl serverCommonPacketListener && serverCommonPacketListener.processedDisconnect) return; // CraftBukkit - Don't handle sync packets for kicked players
                 if (listener.shouldHandleMessage(packet)) {
                     try {
+                        final ca.spottedleaf.leafprofiler.RegionizedProfiler.Handle profiler = io.papermc.paper.threadedregions.TickRegionScheduler.getProfiler(); // Folia - profiler
+                        final int packetTimerId = profiler.getOrCreateTimerAndStart(() -> "Packet Handler: ".concat(io.papermc.paper.util.ObfHelper.INSTANCE.deobfClassName(packet.getClass().getName()))); try { // Folia - profiler
                         packet.handle(listener);
+                        } finally { profiler.stopTimer(packetTimerId); } // Folia - profiler
                     } catch (Exception exception) {
                         if (exception instanceof ReportedException) {
                             ReportedException reportedexception = (ReportedException) exception;
diff --git a/src/main/java/net/minecraft/server/MinecraftServer.java b/src/main/java/net/minecraft/server/MinecraftServer.java
index 28b3a1d2d2bb4bac8abc6f7ca877ce133110a455..ce51c9e98aabf6d4a2a5c8c4eff80608c0dc9bd3 100644
--- a/src/main/java/net/minecraft/server/MinecraftServer.java
+++ b/src/main/java/net/minecraft/server/MinecraftServer.java
@@ -1713,6 +1713,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
     // Folia start - region threading
     public void tickServer(long startTime, long scheduledEnd, long targetBuffer,
                            io.papermc.paper.threadedregions.TickRegions.TickRegionData region) {
+        final ca.spottedleaf.leafprofiler.RegionizedProfiler.Handle foliaProfiler = io.papermc.paper.threadedregions.TickRegionScheduler.getProfiler(); // Folia - profiler
         // Folia end - region threading
         org.spigotmc.WatchdogThread.tick(); // Spigot
         long i = startTime; // Folia - region threading
@@ -1751,6 +1752,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
             }
         }
 
+
         // Folia start - region threading
         if (region != null) {
             region.world.getCurrentWorldData().updateTickData();
@@ -1774,10 +1776,16 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         new com.destroystokyo.paper.event.server.ServerTickStartEvent((int)region.getCurrentTick()).callEvent(); // Paper - Server Tick Events // Folia - region threading
         // Folia start - region threading
         if (region != null) {
+            foliaProfiler.startTimer(ca.spottedleaf.leafprofiler.LProfilerRegistry.INTERNAL_TICK_TASKS); try { // Folia - profiler
             region.getTaskQueueData().drainTasks();
+            } finally { foliaProfiler.stopTimer(ca.spottedleaf.leafprofiler.LProfilerRegistry.INTERNAL_TICK_TASKS); } // Folia - profiler
+            foliaProfiler.startTimer(ca.spottedleaf.leafprofiler.LProfilerRegistry.PLUGIN_TICK_TASKS); try { // Folia - profiler
             ((io.papermc.paper.threadedregions.scheduler.FoliaRegionScheduler)Bukkit.getRegionScheduler()).tick();
+            } finally { foliaProfiler.stopTimer(ca.spottedleaf.leafprofiler.LProfilerRegistry.PLUGIN_TICK_TASKS); } // Folia - profiler
             // now run all the entity schedulers
             // TODO there has got to be a more efficient variant of this crap
+            long tickedEntitySchedulers = 0L; // Folia - profiler
+            foliaProfiler.startTimer(ca.spottedleaf.leafprofiler.LProfilerRegistry.ENTITY_SCHEDULER_TICK); try { // Folia - profiler
             for (Entity entity : region.world.getCurrentWorldData().getLocalEntitiesCopy()) {
                 if (!ca.spottedleaf.moonrise.common.util.TickThread.isTickThreadFor(entity) || entity.isRemoved()) {
                     continue;
@@ -1785,8 +1793,11 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
                 org.bukkit.craftbukkit.entity.CraftEntity bukkit = entity.getBukkitEntityRaw();
                 if (bukkit != null) {
                     bukkit.taskScheduler.executeTick();
+                    ++tickedEntitySchedulers; // Folia - profiler
                 }
             }
+            foliaProfiler.addCounter(ca.spottedleaf.leafprofiler.LProfilerRegistry.ENTITY_SCHEDULERS_TICKED, tickedEntitySchedulers); // Folia - profiler
+            } finally { foliaProfiler.stopTimer(ca.spottedleaf.leafprofiler.LProfilerRegistry.ENTITY_SCHEDULER_TICK); } // Folia - profiler
         }
         // Folia end - region threading
         if (region == null) this.tickRateManager.tick(); // Folia - region threading
@@ -1805,6 +1816,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         }
         profiler.push("save");
         final boolean fullSave = autosavePeriod > 0 && io.papermc.paper.threadedregions.RegionizedServer.getCurrentTick() % autosavePeriod == 0; // Folia - region threading
+        foliaProfiler.startTimer(ca.spottedleaf.leafprofiler.LProfilerRegistry.AUTOSAVE); try { // Folia - profiler
         try {
             this.isSaving = true;
             if (playerSaveInterval > 0) {
@@ -1818,6 +1830,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         } finally {
             this.isSaving = false;
         }
+        } finally { foliaProfiler.stopTimer(ca.spottedleaf.leafprofiler.LProfilerRegistry.AUTOSAVE); } // Folia - profiler
         profiler.pop();
         // Paper end - Incremental chunk and player saving
 
@@ -1900,6 +1913,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
     }
 
     protected void tickChildren(BooleanSupplier shouldKeepTicking, io.papermc.paper.threadedregions.TickRegions.TickRegionData region) { // Folia - region threading
+        final ca.spottedleaf.leafprofiler.RegionizedProfiler.Handle profiler = io.papermc.paper.threadedregions.TickRegionScheduler.getProfiler(); // Folia - profiler
         final io.papermc.paper.threadedregions.RegionizedWorldData regionizedWorldData = io.papermc.paper.threadedregions.TickRegionScheduler.getCurrentRegionizedWorldData(); // Folia - regionised ticking
         ProfilerFiller gameprofilerfiller = Profiler.get();
 
@@ -1964,7 +1978,9 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
             gameprofilerfiller.push("tick");
 
             try {
+                profiler.startTimer(worldserver.tickTimerId); try { // Folia - profiler
                 worldserver.tick(shouldKeepTicking, region); // Folia - region threading
+                } finally { profiler.stopTimer(worldserver.tickTimerId); } // Folia - profiler
             } catch (Throwable throwable) {
                 CrashReport crashreport = CrashReport.forThrowable(throwable, "Exception ticking world");
 
@@ -1979,8 +1995,10 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         if (region == null) this.isIteratingOverLevels = false; // Paper - Throw exception on world create while being ticked // Folia - region threading
 
         gameprofilerfiller.popPush("connection");
+        profiler.startTimer(ca.spottedleaf.leafprofiler.LProfilerRegistry.CONNECTION_TICK); try { // Folia - profiler
         if (region == null) this.tickConnection(); // Folia - region threading
         if (region != null) regionizedWorldData.tickConnections(); // Folia - region threading
+        } finally { profiler.stopTimer(ca.spottedleaf.leafprofiler.LProfilerRegistry.CONNECTION_TICK); } // Folia - profiler
         gameprofilerfiller.popPush("players");
         if (false) this.playerList.tick(); // Folia - region threading
         if (SharedConstants.IS_RUNNING_IN_IDE && this.tickRateManager.runsNormally()) {
diff --git a/src/main/java/net/minecraft/server/level/ChunkMap.java b/src/main/java/net/minecraft/server/level/ChunkMap.java
index 1668011de11a5ed513815fa1b547ff3a7636cc13..74cd86aea1a82f169cb50dac14a8973c97cca88d 100644
--- a/src/main/java/net/minecraft/server/level/ChunkMap.java
+++ b/src/main/java/net/minecraft/server/level/ChunkMap.java
@@ -406,13 +406,18 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
     }
 
     protected void tick(BooleanSupplier shouldKeepTicking) {
+        final ca.spottedleaf.leafprofiler.RegionizedProfiler.Handle profiler = io.papermc.paper.threadedregions.TickRegionScheduler.getProfiler(); // Folia - profiler
         ProfilerFiller gameprofilerfiller = Profiler.get();
 
         gameprofilerfiller.push("poi");
+        profiler.startTimer(ca.spottedleaf.leafprofiler.LProfilerRegistry.POI_MANAGER_TICK); try { // Folia - profiler
         this.poiManager.tick(shouldKeepTicking);
+        } finally { profiler.stopTimer(ca.spottedleaf.leafprofiler.LProfilerRegistry.POI_MANAGER_TICK); } // Folia - profiler
         gameprofilerfiller.popPush("chunk_unload");
         if (!this.level.noSave()) {
+            profiler.startTimer(ca.spottedleaf.leafprofiler.LProfilerRegistry.PROCESS_UNLOADS); try { // Folia - profiler
             this.processUnloads(shouldKeepTicking);
+            } finally { profiler.stopTimer(ca.spottedleaf.leafprofiler.LProfilerRegistry.PROCESS_UNLOADS); } // Folia - profiler
         }
 
         gameprofilerfiller.pop();
@@ -941,12 +946,17 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
 
     // Paper start - optimise entity tracker
     private void newTrackerTick() {
+        // Folia start - profiler
+        final ca.spottedleaf.leafprofiler.RegionizedProfiler.Handle profiler = io.papermc.paper.threadedregions.TickRegionScheduler.getProfiler();
+        final int totalEntities;
+        profiler.startTimer(ca.spottedleaf.leafprofiler.LProfilerRegistry.ENTITY_TRACKER_TICK); try { // Folia - profiler
+        // Folia end - profiler
         final io.papermc.paper.threadedregions.RegionizedWorldData worldData = this.level.getCurrentWorldData(); // Folia - region threading
         final ca.spottedleaf.moonrise.patches.chunk_system.level.entity.server.ServerEntityLookup entityLookup = (ca.spottedleaf.moonrise.patches.chunk_system.level.entity.server.ServerEntityLookup)((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemServerLevel)this.level).moonrise$getEntityLookup();;
 
         final ca.spottedleaf.moonrise.common.list.ReferenceList<net.minecraft.world.entity.Entity> trackerEntities = worldData.trackerEntities; // Folia - region threading
         final Entity[] trackerEntitiesRaw = trackerEntities.getRawDataUnchecked();
-        for (int i = 0, len = trackerEntities.size(); i < len; ++i) {
+        for (int i = 0, len = totalEntities = trackerEntities.size(); i < len; ++i) { // Folia - region threading
             final Entity entity = trackerEntitiesRaw[i];
             final ChunkMap.TrackedEntity tracker = ((ca.spottedleaf.moonrise.patches.entity_tracker.EntityTrackerEntity)entity).moonrise$getTrackedEntity();
             if (tracker == null) {
@@ -958,6 +968,8 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
                 tracker.serverEntity.sendChanges();
             }
         }
+        profiler.addCounter(ca.spottedleaf.leafprofiler.LProfilerRegistry.TRACKED_ENTITY_COUNTS, (long)totalEntities); // Folia - profiler
+        } finally { profiler.stopTimer(ca.spottedleaf.leafprofiler.LProfilerRegistry.ENTITY_TRACKER_TICK); } // Folia - profiler
     }
     // Paper end - optimise entity tracker
 
diff --git a/src/main/java/net/minecraft/server/level/ServerChunkCache.java b/src/main/java/net/minecraft/server/level/ServerChunkCache.java
index 16001634fef7573e5363d2903e2b665bc12d3431..a5fc3187438467d24a3143a01188824bb7120b2a 100644
--- a/src/main/java/net/minecraft/server/level/ServerChunkCache.java
+++ b/src/main/java/net/minecraft/server/level/ServerChunkCache.java
@@ -455,18 +455,25 @@ public class ServerChunkCache extends ChunkSource implements ca.spottedleaf.moon
 
     @Override
     public void tick(BooleanSupplier shouldKeepTicking, boolean tickChunks) {
+        final ca.spottedleaf.leafprofiler.RegionizedProfiler.Handle foliaProfiler = io.papermc.paper.threadedregions.TickRegionScheduler.getProfiler(); // Folia - profiler
         ProfilerFiller gameprofilerfiller = Profiler.get();
 
         gameprofilerfiller.push("purge");
+        foliaProfiler.startTimer(ca.spottedleaf.leafprofiler.LProfilerRegistry.CHUNK_HOLDER_MANAGER_TICK); try { // Folia - profiler
         if (this.level.tickRateManager().runsNormally() || !tickChunks || this.level.spigotConfig.unloadFrozenChunks) { // Spigot
             this.distanceManager.purgeStaleTickets();
         }
 
         this.runDistanceManagerUpdates();
+        } finally { foliaProfiler.stopTimer(ca.spottedleaf.leafprofiler.LProfilerRegistry.CHUNK_HOLDER_MANAGER_TICK); } // Folia - profiler
         gameprofilerfiller.popPush("chunks");
         if (tickChunks) {
+            foliaProfiler.startTimer(ca.spottedleaf.leafprofiler.LProfilerRegistry.PLAYER_CHUNK_LOADER_TICK); try { // Folia - profiler
             ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemServerLevel)this.level).moonrise$getPlayerChunkLoader().tick(); // Paper - rewrite chunk system
+            } finally { foliaProfiler.stopTimer(ca.spottedleaf.leafprofiler.LProfilerRegistry.PLAYER_CHUNK_LOADER_TICK); } // Folia - profiler
+            foliaProfiler.startTimer(ca.spottedleaf.leafprofiler.LProfilerRegistry.CHUNK_TICK); try { // Folia - profiler
             this.tickChunks();
+            } finally { foliaProfiler.stopTimer(ca.spottedleaf.leafprofiler.LProfilerRegistry.CHUNK_TICK); } // Folia - profiler
             this.chunkMap.tick();
         }
 
@@ -478,6 +485,7 @@ public class ServerChunkCache extends ChunkSource implements ca.spottedleaf.moon
 
     private void tickChunks() {
         io.papermc.paper.threadedregions.RegionizedWorldData regionizedWorldData = this.level.getCurrentWorldData(); // Folia - region threading
+        final ca.spottedleaf.leafprofiler.RegionizedProfiler.Handle foliaProfiler = io.papermc.paper.threadedregions.TickRegionScheduler.getProfiler(); // Folia - profiler
         //long i = this.level.getGameTime(); // Folia - region threading
         long j = 1L; // Folia - region threading
 
@@ -491,7 +499,9 @@ public class ServerChunkCache extends ChunkSource implements ca.spottedleaf.moon
 
                 try {
                     gameprofilerfiller.push("filteringTickingChunks");
+                    foliaProfiler.startTimer(ca.spottedleaf.leafprofiler.LProfilerRegistry.CHUNK_TICK_COLLECT_CHUNKS); try { // Folia - profiler
                     this.collectTickingChunks(list);
+                    } finally { foliaProfiler.stopTimer(ca.spottedleaf.leafprofiler.LProfilerRegistry.CHUNK_TICK_COLLECT_CHUNKS); } // Folia - profiler
                     gameprofilerfiller.popPush("shuffleChunks");
                     // Paper start - chunk tick iteration optimisation
                     this.shuffleRandom.setSeed(this.level.random.nextLong());
@@ -504,7 +514,9 @@ public class ServerChunkCache extends ChunkSource implements ca.spottedleaf.moon
                 }
             }
 
+            foliaProfiler.startTimer(ca.spottedleaf.leafprofiler.LProfilerRegistry.BROADCAST_BLOCK_CHANGES); try { // Folia - profiler
             this.broadcastChangedChunks(gameprofilerfiller);
+            } finally { foliaProfiler.stopTimer(ca.spottedleaf.leafprofiler.LProfilerRegistry.BROADCAST_BLOCK_CHANGES); } // Folia - profiler
             gameprofilerfiller.pop();
         }
     }
@@ -552,11 +564,13 @@ public class ServerChunkCache extends ChunkSource implements ca.spottedleaf.moon
 
     private void tickChunks(ProfilerFiller profiler, long timeDelta, List<LevelChunk> chunks) {
         io.papermc.paper.threadedregions.RegionizedWorldData regionizedWorldData = this.level.getCurrentWorldData(); // Folia - region threading
+        final ca.spottedleaf.leafprofiler.RegionizedProfiler.Handle foliaProfiler = io.papermc.paper.threadedregions.TickRegionScheduler.getProfiler(); // Folia - profiler
         profiler.popPush("naturalSpawnCount");
         int j = this.distanceManager.getNaturalSpawnChunkCount();
         // Paper start - Optional per player mob spawns
         final int naturalSpawnChunkCount = j;
         NaturalSpawner.SpawnState spawnercreature_d; // moved down
+        foliaProfiler.startTimer(ca.spottedleaf.leafprofiler.LProfilerRegistry.MOB_SPAWN_ENTITY_COUNT); try { // Folia - profiler
         if ((this.spawnFriendlies || this.spawnEnemies) && this.level.paperConfig().entities.spawning.perPlayerMobSpawns) { // don't count mobs when animals and monsters are disabled
             // re-set mob counts
             for (ServerPlayer player : this.level.getLocalPlayers()) { // Folia - region threading
@@ -576,6 +590,7 @@ public class ServerChunkCache extends ChunkSource implements ca.spottedleaf.moon
         } else {
             spawnercreature_d = NaturalSpawner.createState(naturalSpawnChunkCount, regionizedWorldData.getLoadedEntities(), this::getFullChunk, !this.level.paperConfig().entities.spawning.perPlayerMobSpawns ? new LocalMobCapCalculator(this.chunkMap) : null, false); // Folia - region threading - note: function only cares about loaded entities, doesn't need all
         }
+        } finally { foliaProfiler.stopTimer(ca.spottedleaf.leafprofiler.LProfilerRegistry.MOB_SPAWN_ENTITY_COUNT); } // Folia - profiler
         // Paper end - Optional per player mob spawns
 
         regionizedWorldData.lastSpawnState = spawnercreature_d; // Folia - region threading
@@ -602,6 +617,9 @@ public class ServerChunkCache extends ChunkSource implements ca.spottedleaf.moon
 
         Iterator iterator = chunks.iterator();
 
+        long spawnChunkCount = 0L; // Folia - profiler
+        long randomChunkCount = 0L; // Folia - profiler
+        foliaProfiler.startTimer(ca.spottedleaf.leafprofiler.LProfilerRegistry.SPAWN_AND_RANDOM_TICK); try { // Folia - profiler
         while (iterator.hasNext()) {
             LevelChunk chunk = (LevelChunk) iterator.next();
             ChunkPos chunkcoordintpair = chunk.getPos();
@@ -615,10 +633,15 @@ public class ServerChunkCache extends ChunkSource implements ca.spottedleaf.moon
                 this.level.tickChunk(chunk, k);
             }
         }
+        foliaProfiler.addCounter(ca.spottedleaf.leafprofiler.LProfilerRegistry.SPAWN_CHUNK_COUNT, spawnChunkCount); // Folia - profiler
+        foliaProfiler.addCounter(ca.spottedleaf.leafprofiler.LProfilerRegistry.RANDOM_CHUNK_TICK_COUNT, randomChunkCount); // Folia - profiler
+        } finally { foliaProfiler.stopTimer(ca.spottedleaf.leafprofiler.LProfilerRegistry.SPAWN_AND_RANDOM_TICK); } // Folia - profiler
 
         profiler.popPush("customSpawners");
         if (flag) {
+            foliaProfiler.startTimer(ca.spottedleaf.leafprofiler.LProfilerRegistry.MISC_MOB_SPAWN_TICK); try { // Folia - profiler
             this.level.tickCustomSpawners(this.spawnEnemies, this.spawnFriendlies);
+            } finally { foliaProfiler.stopTimer(ca.spottedleaf.leafprofiler.LProfilerRegistry.MISC_MOB_SPAWN_TICK); } // Folia - profiler
         }
 
     }
diff --git a/src/main/java/net/minecraft/server/level/ServerLevel.java b/src/main/java/net/minecraft/server/level/ServerLevel.java
index cb2c0358fb462c4a5ebf94299119c2081dc5f78f..cd1af13c91b215d896618fa0f2790da1a53ea80a 100644
--- a/src/main/java/net/minecraft/server/level/ServerLevel.java
+++ b/src/main/java/net/minecraft/server/level/ServerLevel.java
@@ -725,6 +725,7 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
 
     public void tick(BooleanSupplier shouldKeepTicking, io.papermc.paper.threadedregions.TickRegions.TickRegionData region) { // Folia - regionised ticking
         final io.papermc.paper.threadedregions.RegionizedWorldData regionizedWorldData = this.getCurrentWorldData(); // Folia - regionised ticking
+        final ca.spottedleaf.leafprofiler.RegionizedProfiler.Handle profiler = io.papermc.paper.threadedregions.TickRegionScheduler.getProfiler(); // Folia - profiler
         ProfilerFiller gameprofilerfiller = Profiler.get();
 
         regionizedWorldData.setHandlingTick(true); // Folia - regionised ticking
@@ -753,22 +754,32 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
         if (!this.isDebug() && flag) {
             j = regionizedWorldData.getRedstoneGameTime(); // Folia - region threading
             gameprofilerfiller.push("blockTicks");
+            profiler.startTimer(ca.spottedleaf.leafprofiler.LProfilerRegistry.BLOCK_TICK); try { // Folia - profiler
             regionizedWorldData.getBlockLevelTicks().tick(j, paperConfig().environment.maxBlockTicks, this::tickBlock); // Paper - configurable max block ticks // Folia - region ticking
+            } finally { profiler.stopTimer(ca.spottedleaf.leafprofiler.LProfilerRegistry.BLOCK_TICK); } // Folia - profiler
             gameprofilerfiller.popPush("fluidTicks");
+            profiler.startTimer(ca.spottedleaf.leafprofiler.LProfilerRegistry.FLUID_TICK); try { // Folia - profiler
             regionizedWorldData.getFluidLevelTicks().tick(j, paperConfig().environment.maxFluidTicks, this::tickFluid); // Paper - configurable max fluid ticks // Folia - region ticking
+            } finally { profiler.stopTimer(ca.spottedleaf.leafprofiler.LProfilerRegistry.FLUID_TICK); } // Folia - profiler
             gameprofilerfiller.pop();
         }
 
         gameprofilerfiller.popPush("raid");
         if (flag) {
+            profiler.startTimer(ca.spottedleaf.leafprofiler.LProfilerRegistry.RAIDS_TICK); try { // Folia - profiler
             this.raids.tick();
+            } finally { profiler.stopTimer(ca.spottedleaf.leafprofiler.LProfilerRegistry.RAIDS_TICK); } // Folia - profiler
         }
 
         gameprofilerfiller.popPush("chunkSource");
+        profiler.startTimer(ca.spottedleaf.leafprofiler.LProfilerRegistry.CHUNK_PROVIDER_TICK); try { // Folia - profiler
         this.getChunkSource().tick(shouldKeepTicking, true);
+        } finally { profiler.stopTimer(ca.spottedleaf.leafprofiler.LProfilerRegistry.CHUNK_PROVIDER_TICK); } // Folia - profiler
         gameprofilerfiller.popPush("blockEvents");
         if (flag) {
+            profiler.startTimer(ca.spottedleaf.leafprofiler.LProfilerRegistry.BLOCK_EVENT_TICK); try { // Folia - profiler
             this.runBlockEvents();
+            } finally { profiler.stopTimer(ca.spottedleaf.leafprofiler.LProfilerRegistry.BLOCK_EVENT_TICK); } // Folia - profiler
         }
 
         regionizedWorldData.setHandlingTick(false); // Folia - regionised ticking
@@ -782,6 +793,7 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
         if (flag1 || this.emptyTime++ < 300) {
             gameprofilerfiller.push("entities");
             if (this.dragonFight != null && flag) {
+                profiler.startTimer(ca.spottedleaf.leafprofiler.LProfilerRegistry.DRAGON_FIGHT_TICK); try { // Folia - profiler
                 if (ca.spottedleaf.moonrise.common.util.TickThread.isTickThreadFor(this, this.dragonFight.origin)) { // Folia - region threading
                 gameprofilerfiller.push("dragonFight");
                 this.dragonFight.tick();
@@ -794,9 +806,13 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
                         fightCenter
                     );
                 } // Folia end - region threading
+                } finally { profiler.stopTimer(ca.spottedleaf.leafprofiler.LProfilerRegistry.DRAGON_FIGHT_TICK); } // Folia - profiler
             }
 
+            profiler.startTimer(ca.spottedleaf.leafprofiler.LProfilerRegistry.ACTIVATE_ENTITIES); try { // Folia - profiler
             org.spigotmc.ActivationRange.activateEntities(this); // Spigot
+            } finally { profiler.stopTimer(ca.spottedleaf.leafprofiler.LProfilerRegistry.ACTIVATE_ENTITIES); } // Folia - profiler
+            profiler.startTimer(ca.spottedleaf.leafprofiler.LProfilerRegistry.ENTITY_TICK); try { // Folia - profiler
             regionizedWorldData.forEachTickingEntity((entity) -> { // Folia - regionised ticking
                 if (!entity.isRemoved()) {
                     if (!tickratemanager.isEntityFrozen(entity)) {
@@ -822,8 +838,11 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
                     }
                 }
             });
+            } finally { profiler.stopTimer(ca.spottedleaf.leafprofiler.LProfilerRegistry.ENTITY_TICK); } // Folia - profiler
             gameprofilerfiller.pop();
+            profiler.startTimer(ca.spottedleaf.leafprofiler.LProfilerRegistry.TILE_ENTITY); try { // Folia - profiler
             this.tickBlockEntities();
+            } finally { profiler.stopTimer(ca.spottedleaf.leafprofiler.LProfilerRegistry.TILE_ENTITY); } // Folia - profiler
         }
 
         gameprofilerfiller.push("entityManagement");
@@ -885,12 +904,15 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
     }
 
     public void tickCustomSpawners(boolean spawnMonsters, boolean spawnAnimals) {
+        final ca.spottedleaf.leafprofiler.RegionizedProfiler.Handle profiler = io.papermc.paper.threadedregions.TickRegionScheduler.getProfiler(); // Folia - profiler
         Iterator iterator = this.customSpawners.iterator();
 
         while (iterator.hasNext()) {
             CustomSpawner mobspawner = (CustomSpawner) iterator.next();
 
+            final int customSpawnerTimer = profiler.getOrCreateTimerAndStart(() -> "Misc Spawner: ".concat(io.papermc.paper.util.ObfHelper.INSTANCE.deobfClassName(mobspawner.getClass().getName()))); try { // Folia - profiler
             mobspawner.tick(this, spawnMonsters, spawnAnimals);
+            } finally { profiler.stopTimer(customSpawnerTimer); } // Folia - profiler
         }
 
     }
@@ -1345,6 +1367,12 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
         });
         gameprofilerfiller.incrementCounter("tickNonPassenger");
         final boolean isActive = org.spigotmc.ActivationRange.checkIfActive(entity); // Paper - EAR 2
+        // Folia start - profiler
+        final int timerId = isActive ? entity.getType().tickTimerId : entity.getType().inactiveTickTimerId;
+        final ca.spottedleaf.leafprofiler.RegionizedProfiler.Handle profiler = io.papermc.paper.threadedregions.TickRegionScheduler.getProfiler();
+        profiler.startTimer(timerId);
+        try {
+        // Folia end - profiler
         if (isActive) { // Paper - EAR 2
         entity.tick();
         // Folia start - region threading
@@ -1359,6 +1387,7 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
         // Folia end - region threading
         } else { entity.inactiveTick(); } // Paper - EAR 2
         gameprofilerfiller.pop();
+        } finally { profiler.stopTimer(timerId); } // Folia - timer
         Iterator iterator = entity.getPassengers().iterator();
 
         while (iterator.hasNext()) {
@@ -1377,6 +1406,12 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
     private void tickPassenger(Entity vehicle, Entity passenger, boolean isActive) { // Paper - EAR 2
         if (!passenger.isRemoved() && passenger.getVehicle() == vehicle) {
             if (passenger instanceof Player || this.getCurrentWorldData().hasEntityTickingEntity(passenger)) { // Folia - region threading
+                // Folia start - profiler
+                final int timerId = isActive ? passenger.getType().tickTimerId : passenger.getType().inactiveTickTimerId;
+                final ca.spottedleaf.leafprofiler.RegionizedProfiler.Handle profiler = io.papermc.paper.threadedregions.TickRegionScheduler.getProfiler();
+                profiler.startTimer(timerId);
+                try {
+                // Folia end - profiler
                 passenger.setOldPosAndRot();
                 ++passenger.tickCount;
                 ProfilerFiller gameprofilerfiller = Profiler.get();
@@ -1414,6 +1449,7 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
                     this.tickPassenger(passenger, entity2, isActive); // Paper - EAR 2
                 }
 
+                } finally { profiler.stopTimer(timerId); } // Folia - profiler
             }
         } else {
             passenger.stopRiding();
diff --git a/src/main/java/net/minecraft/server/players/PlayerList.java b/src/main/java/net/minecraft/server/players/PlayerList.java
index c5b67dccdd15d3d8a7d950d397eeffba392bec17..995ea080be9ee8e3b246723e115e312d2f0984bb 100644
--- a/src/main/java/net/minecraft/server/players/PlayerList.java
+++ b/src/main/java/net/minecraft/server/players/PlayerList.java
@@ -1258,6 +1258,7 @@ public abstract class PlayerList {
 
     public void saveAll(int interval) {
         io.papermc.paper.util.MCUtil.ensureMain("Save Players" , () -> { // Paper - Ensure main
+        final ca.spottedleaf.leafprofiler.RegionizedProfiler.Handle profiler = io.papermc.paper.threadedregions.TickRegionScheduler.getProfiler(); // Folia - profiler
         int numSaved = 0;
         long now = System.nanoTime(); // Folia - region threading
         long timeInterval = (long)interval * io.papermc.paper.threadedregions.TickRegionScheduler.TIME_BETWEEN_TICKS; // Folia - region threading
@@ -1268,7 +1269,9 @@ public abstract class PlayerList {
             }
             // Folia end - region threading
             if (interval == -1 || now - player.lastSave >= timeInterval) { // Folia - region threading
+                profiler.startTimer(ca.spottedleaf.leafprofiler.LProfilerRegistry.PLAYER_SAVE); try { // Folia - profiler
                 this.save(player);
+                } finally { profiler.stopTimer(ca.spottedleaf.leafprofiler.LProfilerRegistry.PLAYER_SAVE); } // Folia - profiler
                 if (interval != -1 && ++numSaved >= io.papermc.paper.configuration.GlobalConfiguration.get().playerAutoSave.maxPerTick()) { break; }
             }
             // Paper end - Incremental chunk and player saving
diff --git a/src/main/java/net/minecraft/world/entity/EntityType.java b/src/main/java/net/minecraft/world/entity/EntityType.java
index c8c2394558952d7ca57d29874485251b8f2b3400..0d18403c6c25555f78e2d6810520839f30258c8e 100644
--- a/src/main/java/net/minecraft/world/entity/EntityType.java
+++ b/src/main/java/net/minecraft/world/entity/EntityType.java
@@ -412,7 +412,20 @@ public class EntityType<T extends Entity> implements FeatureElement, EntityTypeT
         return BuiltInRegistries.ENTITY_TYPE.getOptional(ResourceLocation.tryParse(id));
     }
 
-    public EntityType(EntityType.EntityFactory<T> factory, MobCategory spawnGroup, boolean saveable, boolean summonable, boolean fireImmune, boolean spawnableFarFromPlayer, ImmutableSet<Block> canSpawnInside, EntityDimensions dimensions, float spawnBoxScale, int maxTrackDistance, int trackTickInterval, String translationKey, Optional<ResourceKey<LootTable>> lootTable, FeatureFlagSet requiredFeatures) {
+    // Folia start - profiler
+    public final int tickTimerId;
+    public final int inactiveTickTimerId;
+    public final int passengerTickTimerId;
+    public final int passengerInactiveTickTimerId;
+    // Folia end - profiler
+
+    // Folia start - profiler
+    public EntityType(EntityType.EntityFactory<T> factory, MobCategory spawnGroup, boolean saveable, boolean summonable, boolean fireImmune, boolean spawnableFarFromPlayer, ImmutableSet<Block> canSpawnInside, EntityDimensions dimensions, float spawnBoxScale, int maxTrackDistance, int trackTickInterval, String translationKey, Optional<ResourceKey<LootTable>> lootTable, FeatureFlagSet requiredFeatures, String id) {
+        this.tickTimerId = ca.spottedleaf.leafprofiler.LProfilerRegistry.GLOBAL_REGISTRY.getOrCreateTimer("Entity Tick: " + id);
+        this.inactiveTickTimerId = ca.spottedleaf.leafprofiler.LProfilerRegistry.GLOBAL_REGISTRY.getOrCreateTimer("Inactive Entity Tick: " + id);
+        this.passengerTickTimerId = ca.spottedleaf.leafprofiler.LProfilerRegistry.GLOBAL_REGISTRY.getOrCreateTimer("Passenger Entity Tick: " + id);
+        this.passengerInactiveTickTimerId = ca.spottedleaf.leafprofiler.LProfilerRegistry.GLOBAL_REGISTRY.getOrCreateTimer("Passenger Inactive Entity Tick: " + id);
+        // Folia end - profiler
         this.builtInRegistryHolder = BuiltInRegistries.ENTITY_TYPE.createIntrusiveHolder(this);
         this.factory = factory;
         this.category = spawnGroup;
@@ -963,7 +976,7 @@ public class EntityType<T extends Entity> implements FeatureElement, EntityTypeT
                 Util.fetchChoiceType(References.ENTITY_TREE, registryKey.location().toString());
             }
 
-            return new EntityType<>(this.factory, this.category, this.serialize, this.summon, this.fireImmune, this.canSpawnFarFromPlayer, this.immuneTo, this.dimensions.withAttachments(this.attachments), this.spawnDimensionsScale, this.clientTrackingRange, this.updateInterval, (String) this.descriptionId.get(registryKey), (Optional) this.lootTable.get(registryKey), this.requiredFeatures);
+            return new EntityType<>(this.factory, this.category, this.serialize, this.summon, this.fireImmune, this.canSpawnFarFromPlayer, this.immuneTo, this.dimensions.withAttachments(this.attachments), this.spawnDimensionsScale, this.clientTrackingRange, this.updateInterval, (String) this.descriptionId.get(registryKey), (Optional) this.lootTable.get(registryKey), this.requiredFeatures, registryKey.toString()); // Folia - profiler
         }
     }
 
diff --git a/src/main/java/net/minecraft/world/level/Level.java b/src/main/java/net/minecraft/world/level/Level.java
index 54bafb8f67361525484c5c58ee8e6568c0801477..3d96f7ae648b47cc7494578d9776e7ea6dee0964 100644
--- a/src/main/java/net/minecraft/world/level/Level.java
+++ b/src/main/java/net/minecraft/world/level/Level.java
@@ -204,6 +204,9 @@ public abstract class Level implements LevelAccessor, AutoCloseable, ca.spottedl
     public final ca.spottedleaf.moonrise.patches.chunk_system.level.entity.EntityLookup moonrise$getEntityLookup() {
         return this.entityLookup;
     }
+    // Folia start - profiler
+    public final int tickTimerId;
+    // Folia end - profiler
 
     @Override
     public final void moonrise$setEntityLookup(final ca.spottedleaf.moonrise.patches.chunk_system.level.entity.EntityLookup entityLookup) {
@@ -936,6 +939,9 @@ public abstract class Level implements LevelAccessor, AutoCloseable, ca.spottedl
         this.tileLimiter = new org.spigotmc.TickLimiter(this.spigotConfig.tileMaxTickTime);
         this.chunkPacketBlockController = this.paperConfig().anticheat.antiXray.enabled ? new com.destroystokyo.paper.antixray.ChunkPacketBlockControllerAntiXray(this, executor) : com.destroystokyo.paper.antixray.ChunkPacketBlockController.NO_OPERATION_INSTANCE; // Paper - Anti-Xray
         this.entityLookup = new ca.spottedleaf.moonrise.patches.chunk_system.level.entity.dfl.DefaultEntityLookup(this); // Paper - rewrite chunk system
+        // Folia start - profiler
+        this.tickTimerId = ca.spottedleaf.leafprofiler.LProfilerRegistry.GLOBAL_REGISTRY.getOrCreateTimer("Tick World: " + resourcekey.location().toString());
+        // Folia end - profiler
     }
 
     // Paper start - Cancel hit for vanished players
@@ -1480,14 +1486,18 @@ public abstract class Level implements LevelAccessor, AutoCloseable, ca.spottedl
     }
 
     protected void tickBlockEntities() {
+        final ca.spottedleaf.leafprofiler.RegionizedProfiler.Handle profiler = io.papermc.paper.threadedregions.TickRegionScheduler.getProfiler(); // Folia - profiler
         ProfilerFiller gameprofilerfiller = Profiler.get();
 
         gameprofilerfiller.push("blockEntities");
         final io.papermc.paper.threadedregions.RegionizedWorldData regionizedWorldData = this.getCurrentWorldData(); // Folia - regionised ticking
         regionizedWorldData.seTtickingBlockEntities(true); // Folia - regionised ticking
+        profiler.startTimer(ca.spottedleaf.leafprofiler.LProfilerRegistry.TILE_ENTITY_PENDING); try { // Folia - profiler
         regionizedWorldData.pushPendingTickingBlockEntities(); // Folia - regionised ticking
+        } finally { profiler.stopTimer(ca.spottedleaf.leafprofiler.LProfilerRegistry.TILE_ENTITY_PENDING); } // Folia - profiler
         List<TickingBlockEntity> blockEntityTickers = regionizedWorldData.getBlockEntityTickers(); // Folia - regionised ticking
 
+        profiler.startTimer(ca.spottedleaf.leafprofiler.LProfilerRegistry.TILE_ENTITY_TICK); try { // Folia - profiler
         // Spigot start
         // Iterator<TickingBlockEntity> iterator = this.blockEntityTickers.iterator();
         boolean flag = this.tickRateManager().runsNormally();
@@ -1516,6 +1526,7 @@ public abstract class Level implements LevelAccessor, AutoCloseable, ca.spottedl
             }
         }
         blockEntityTickers.removeAll(toRemove); // Paper - Fix MC-117075 // Folia - regionised ticking
+        } finally { profiler.stopTimer(ca.spottedleaf.leafprofiler.LProfilerRegistry.TILE_ENTITY_TICK); } // Folia - profiler
 
         regionizedWorldData.seTtickingBlockEntities(false); // Folia - regionised ticking
         gameprofilerfiller.pop();
diff --git a/src/main/java/net/minecraft/world/level/block/entity/BlockEntityType.java b/src/main/java/net/minecraft/world/level/block/entity/BlockEntityType.java
index dea945a9b278353647dca3ed001158c198dab668..422c9aeb761092496089a1b2e1dd9c5fe8f5b2bc 100644
--- a/src/main/java/net/minecraft/world/level/block/entity/BlockEntityType.java
+++ b/src/main/java/net/minecraft/world/level/block/entity/BlockEntityType.java
@@ -245,10 +245,14 @@ public class BlockEntityType<T extends BlockEntity> {
         }
 
         Util.fetchChoiceType(References.BLOCK_ENTITY, id);
-        return Registry.register(BuiltInRegistries.BLOCK_ENTITY_TYPE, id, new BlockEntityType<>(blockEntitySupplier, Set.of(blocks)));
+        return Registry.register(BuiltInRegistries.BLOCK_ENTITY_TYPE, id, new BlockEntityType<>(blockEntitySupplier, Set.of(blocks), id)); // Folia - profiler
     }
 
-    private BlockEntityType(BlockEntityType.BlockEntitySupplier<? extends T> factory, Set<Block> blocks) {
+    // Folia start - profiler
+    public final int tileEntityTimingId;
+    private BlockEntityType(BlockEntityType.BlockEntitySupplier<? extends T> factory, Set<Block> blocks, String id) {
+        this.tileEntityTimingId = ca.spottedleaf.leafprofiler.LProfilerRegistry.GLOBAL_REGISTRY.getOrCreateTimer("Tile Entity Tick: " + id);
+        // Folia end - profiler
         this.factory = factory;
         this.validBlocks = blocks;
     }
diff --git a/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java b/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java
index 877f68f9abfc659f489d6571efc1b431e1240ed6..4bccb94cf953ebd4dfd4f1620ad1784ef235356f 100644
--- a/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java
+++ b/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java
@@ -1074,10 +1074,13 @@ public class LevelChunk extends ChunkAccess implements ca.spottedleaf.moonrise.p
                 BlockPos blockposition = this.blockEntity.getBlockPos();
 
                 if (LevelChunk.this.isTicking(blockposition)) {
+                    final ca.spottedleaf.leafprofiler.RegionizedProfiler.Handle profiler = io.papermc.paper.threadedregions.TickRegionScheduler.getProfiler(); // Folia - profiler
+                    final int timerId = this.blockEntity.getType().tileEntityTimingId; // Folia - profiler
                     try {
                         ProfilerFiller gameprofilerfiller = Profiler.get();
 
                         gameprofilerfiller.push(this::getType);
+                        profiler.startTimer(timerId); try { // Folia - profiler
                         BlockState iblockdata = LevelChunk.this.getBlockState(blockposition);
 
                         if (this.blockEntity.getType().isValid(iblockdata)) {
@@ -1092,6 +1095,7 @@ public class LevelChunk extends ChunkAccess implements ca.spottedleaf.moonrise.p
                             }
                             // Paper end - Remove the Block Entity if it's invalid
                         }
+                        } finally { profiler.stopTimer(timerId); } // Folia - profiler
 
                         gameprofilerfiller.pop();
                     } catch (Throwable throwable) {
diff --git a/src/main/java/net/minecraft/world/ticks/LevelTicks.java b/src/main/java/net/minecraft/world/ticks/LevelTicks.java
index 3fc6b4f93885fe447ed068bc5e0784daad655696..7d3067a7df48171f6c8cda12d5da6d721c085a60 100644
--- a/src/main/java/net/minecraft/world/ticks/LevelTicks.java
+++ b/src/main/java/net/minecraft/world/ticks/LevelTicks.java
@@ -248,6 +248,12 @@ public class LevelTicks<T> implements LevelTickAccess<T> {
     }
 
     private void runCollectedTicks(BiConsumer<BlockPos, T> ticker) {
+        // Folia start - profiler
+        io.papermc.paper.threadedregions.TickRegionScheduler.getProfiler().addCounter(
+            ca.spottedleaf.leafprofiler.LProfilerRegistry.BLOCK_OR_FLUID_TICK_COUNT,
+            (long)this.toRunThisTick.size()
+        );
+        // Folia end - profiler
         while (!this.toRunThisTick.isEmpty()) {
             ScheduledTick<T> scheduledTick = this.toRunThisTick.poll();
             if (!this.toRunThisTickSet.isEmpty()) {
